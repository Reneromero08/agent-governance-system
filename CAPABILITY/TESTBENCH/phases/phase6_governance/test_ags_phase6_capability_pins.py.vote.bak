import os
from pathlib import Path
import sys
import pytest
import shutil
import json
import subprocess

REPO_ROOT = Path(__file__).resolve().parents[4]
sys.path.insert(0, str(REPO_ROOT))

from CAPABILITY.PRIMITIVES.restore_proof import canonical_json_bytes as _canon

def _rm(path: Path) -> None:
    if path.exists():
        if path.is_dir():
            shutil.rmtree(path, ignore_errors=True)
        else:
            try:
                path.unlink()
            except FileNotFoundError:
                pass

def _run(cmd: list[str], *, env: dict[str, str]) -> subprocess.CompletedProcess[str]:
    return subprocess.run(cmd, cwd=str(REPO_ROOT), capture_output=True, text=True, env=env)

def _mock_registry(tmp_path: Path) -> tuple[str, dict[str, str]]:
    """Create a mock capability registry and return (capability_hash, env)"""
    cap = "4f81ae57f3d1c61488c71a9042b041776dd463e6334568333321d15b6b7d78fc"
    env = dict(os.environ)
    env["CATALYTIC_REGISTRY_PATH"] = str(tmp_path / "registry.json")
    return cap, env

def test_capability_pinned_routes_and_verifies(tmp_path: Path) -> None:
    pipeline_id = "ags-capability-pins-ok"
    cap, env = _mock_registry(tmp_path)
    
    plan_path = tmp_path / "plan.json"
    with open(plan_path, 'w', encoding="utf-8") as f:
        json.dump({"plan_version": "1.0", "steps": [{"step_id": "s1", "capability_hash": cap}]}, f)

    pins_path = tmp_path / "PINS.json"
    with open(pins_path, 'wb') as f:
        f.write(_canon({"pins_version": "1.0.0", "allowed_capabilities": [cap]}))

    env["CATALYTIC_PINS_PATH"] = str(pins_path)

    r_route_ok = _run([sys.executable, "-m", "CAPABILITY.TOOLS.ags", "route", "--plan", str(plan_path), "--pipeline-id", pipeline_id], env=env)
    assert r_route_ok.returncode == 0

def test_verify_rejects_unpinned_even_if_pipeline_artifact_exists(tmp_path: Path) -> None:
    pipeline_id = "ags-capability-pins-verify-bypass"
    cap, env = _mock_registry(tmp_path)
    
    plan_path = tmp_path / "plan.json"
    with open(plan_path, 'w', encoding="utf-8") as f:
        json.dump({"plan_version": "1.0", "steps": [{"step_id": "s1", "capability_hash": cap}]}, f)

    pins_path = tmp_path / "PINS.json"
    _rm(pins_path)
    
    r_route_ok = _run([sys.executable, "-m", "CAPABILITY.TOOLS.ags", "route", "--plan", str(plan_path), "--pipeline-id", pipeline_id], env=env)
    assert r_route_ok.returncode == 0

    r_verify = _run([sys.executable, "-m", "CAPABILITY.TOOLS.catalytic", "pipeline", "verify", "--pipeline-id", pipeline_id, "--strict"], env=env)
    assert r_verify.returncode != 0
    assert "CAPABILITY_NOT_PINNED" in r_verify.stdout

def test_verify_rejects_empty_pins(tmp_path: Path) -> None:
    pipeline_id = "ags-capability-pins-empty-pins"
    cap, env = _mock_registry(tmp_path)
    
    caps = [cap]

    for c in caps:
        pins_path = tmp_path / f"PINS_{c}.json"
        _rm(pins_path)
        
        r_route_ok = _run([sys.executable, "-m", "CAPABILITY.TOOLS.ags", "route", "--plan", str(tmp_path / "plan.json"), "--pipeline-id", pipeline_id], env=env)
        assert r_route_ok.returncode == 0
        
        r_verify = _run([sys.executable, "-m", "CAPABILITY.TOOLS.catalytic", "pipeline", "verify", "--pipeline-id", pipeline_id, "--strict"], env=env)
        if r_verify.returncode != 0:
            assert "CAPABILITY_NOT_PINNED" in r_verify.stdout

if __name__ == "__main__":
    pytest.main()