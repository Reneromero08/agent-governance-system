import json
import shutil
from pathlib import Path

REPO_ROOT = Path(__file__).resolve().parents[3]

def _rm(path: Path) -> None:
    if path.is_dir():
        shutil.rmtree(path)
    else:
        try:
            path.unlink()
        except FileNotFoundError:
            pass

def _write_jobspec(path: Path, *, job_id: str, intent: str, catalytic_domains: list[str], durable_paths: list[str]) -> None:
    path.parent.mkdir(parents=True, exist_ok=True)
    jobspec = {
        "job_id": job_id,
        "phase": 7,
        "task_type": "test",
        "intent": intent,
        "inputs": {},
        "outputs": {
            "durable_paths": durable_paths,
            "validation_criteria": {}
        },
        "catalytic_domains": catalytic_domains,
        "determinism": "deterministic"
    }
    with open(path, 'w', encoding="utf-8") as f:
        json.dump(jobspec, f, indent=2)

def test_swarm_chain_binds_pipeline_proofs(tmp_path: Path) -> None:
    """
    Phase 7 Acceptance 1: A swarm run produces a top-level chain that binds each pipeline's proof.
    """
    swarm_id = "phase7-chain-ok"
    p1 = "p1"
    p2 = "p2"

    runs_root = REPO_ROOT / "_runs"
    swarm_dir = runs_root / "_pipelines" / "_swarms" / swarm_id
    dag_dir = runs_root / "_dags" / swarm_id

    out1 = runs_root / "_tmp" / f"{p1}.txt"
    out2 = runs_root / "_tmp" / f"{p2}.txt"
    jobspec1_rel = runs_root / "_tmp" / "phase7_test" / f"{p1}_jobspec.json"
    jobspec2_rel = runs_root / "_tmp" / "phase7_test" / f"{p2}_jobspec.json"

    try:
        _rm(swarm_dir)
        _rm(dag_dir)
        _rm(out1)
        _rm(out2)

        _write_jobspec(jobspec1_rel, job_id=f"{p1}-job", intent=p1, catalytic_domains=["LAW/CONTRACTS/_runs/_tmp/phase7_test/domain"], durable_paths=[out1])
        _write_jobspec(jobspec2_rel, job_id=f"{p2}-job", intent=p2, catalytic_domains=["LAW/CONTRACTS/_runs/_tmp/phase7_test/domain"], durable_paths=[out2])

        pipeline_spec_1 = {
            "pipeline_id": p1,
            "steps": [
                {
                    "step_id": "s1",
                    "jobspec_path": str(jobspec1_rel),
                    "memoize": False,
                    "cmd": [sys.executable, "-c", f"from pathlib import Path;Path('{out1}').parent.mkdir(parents=True, exist_ok=True);Path('{out1}').write_text('{p1}')"],
                }
            ]
        }

        pipeline_spec_2 = {
            "pipeline_id": p2,
            "steps": [
                {
                    "step_id": "s1",
                    "jobspec_path": str(jobspec2_rel),
                    "memoize": False,
                    "cmd": [sys.executable, "-c", f"from pathlib import Path;Path('{out2}').parent.mkdir(parents=True, exist_ok=True);Path('{out2}').write_text('{p2}')"],
                }
            ]
        }

        swarm_spec = {
            "swarm_version": "1.0.0",
            "swarm_id": swarm_id,
            "nodes": [
                {
                    "node_id": p1,
                    "pipeline_spec": pipeline_spec_1
                },
                {
                    "node_id": p2,
                    "pipeline_spec": pipeline_spec_2
                }
            ],
            "edges": [
                {
                    "from": p1,
                    "to": p2,
                    "requires": ["CHAIN.json"]
                }
            ]
        }

        spec_path = tmp_path / "swarm.json"
        spec_path.write_text(json.dumps(swarm_spec, indent=2), encoding="utf-8")

        sr = SwarmRuntime(project_root=REPO_ROOT, runs_root=runs_root)
        res = sr.run(swarm_id=swarm_id, spec_path=spec_path)

        assert res.get("ok") is True, "The swarm run should succeed."
    finally:
        chain_path = tmp_path / "CHAIN.json"
        if chain_path.exists():
            print(f"Cleaning up: {chain_path}")
            chain_path.unlink()

def test_swarm_chain_binds_pipeline_proofs_with_tampered_proof(tmp_path: Path) -> None:
    """
    Phase 7 Acceptance 1: A swarm run produces a top-level chain that binds each pipeline's proof.
    """
    # This is a placeholder for the test case with tampered proof
    pass

def verify_chain(chain_path: Path) -> bool:
    """ Placeholder function to check if the chain exists and is valid. """
    return chain_path.exists()

if __name__ == "__main__":
    import pytest
    pytest.main()