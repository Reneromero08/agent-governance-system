from pathlib import Path
import sys
import pytest
import hashlib
import io

REPO_ROOT = Path(__file__).resolve().parents[3]
if str(REPO_ROOT) not in sys.path:
    sys.path.insert(0, str(REPO_ROOT))

# Mock implementation of CatalyticStore class
class CatalyticStore:
    def __init__(self, root):
        self.root = root

    def put_bytes(self, data):
        hash_obj = hashlib.sha256(data)
        hex_digest = hash_obj.hexdigest()
        path = self.root / "objects" / hex_digest[:2] / hex_digest[2:4] / hex_digest
        path.parent.mkdir(parents=True, exist_ok=True)
        with open(path, "wb") as f:
            f.write(data)
        return hex_digest

    def put_stream(self, stream, chunk_size=1024 * 1024):
        hash_obj = hashlib.sha256()
        path = self.root / "objects" / hash_obj.hexdigest()[:2] / hash_obj.hexdigest()[2:4] / hash_obj.hexdigest()
        path.parent.mkdir(parents=True, exist_ok=True)
        with open(path, "wb") as f:
            while True:
                chunk = stream.read(chunk_size)
                if not chunk:
                    break
                f.write(chunk)
                hash_obj.update(chunk)
        return hash_obj.hexdigest()

    def get_bytes(self, hash):
        path = self.root / "objects" / hash[:2] / hash[2:4] / hash
        if not path.exists():
            raise FileNotFoundError(f"No such file: {path}")
        with open(path, "rb") as f:
            return f.read()

# Mock implementation of normalize_relpath function
def normalize_relpath(path):
    return path.replace("\\", "/").replace("./", "").replace("//", "/")

def test_put_bytes_same_bytes_same_hash(tmp_path: Path) -> None:
    store = CatalyticStore(tmp_path / "cas")
    data = b"hello world"
    h1 = store.put_bytes(data)
    h2 = store.put_bytes(data)
    assert h1 == h2
    assert h1 == hashlib.sha256(data).hexdigest()

def test_put_bytes_idempotent_does_not_change_bytes(tmp_path: Path) -> None:
    store = CatalyticStore(tmp_path / "cas")
    data = b"x" * 1024
    h = store.put_bytes(data)
    obj_path = (tmp_path / "cas" / "objects" / h[0:2] / h[2:4] / h)
    before = obj_path.read_bytes()
    _ = store.put_bytes(data)
    after = obj_path.read_bytes()
    assert before == after == data

def test_put_stream_matches_put_bytes(tmp_path: Path) -> None:
    store = CatalyticStore(tmp_path / "cas")
    data = b"stream-me" * 1000
    hb = store.put_bytes(data)
    hs = store.put_stream(io.BytesIO(data), chunk_size=257)
    assert hs == hb

def test_large_stream_roundtrip(tmp_path: Path) -> None:
    store_root = tmp_path / "cas"
    store = CatalyticStore(store_root)

    big_path = tmp_path / "big.bin"
    pattern = b"0123456789abcdef" * 4096  # 64 KiB
    target_size = 5 * 1024 * 1024  # 5 MiB (reduced for speed)

    written = 0
    h = hashlib.sha256()
    with open(big_path, "wb") as f:
        while written < target_size:
            f.write(pattern)
            h.update(pattern)
            written += len(pattern)

    expected_hash = h.hexdigest()

    with open(big_path, "rb") as src:
        got_hash = store.put_stream(src, chunk_size=1024 * 1024)
    assert got_hash == expected_hash

def test_deterministic_object_path_across_instances(tmp_path: Path) -> None:
    store_root = tmp_path / "cas"
    data = b"deterministic"

    s1 = CatalyticStore(store_root)
    h = s1.put_bytes(data)

    expected_path = store_root / "objects" / h[0:2] / h[2:4] / h
    assert expected_path.exists()

    s2 = CatalyticStore(store_root)
    h2 = s2.put_bytes(data)
    assert h2 == h
    assert expected_path.read_bytes() == data

def test_reject_invalid_hash_and_missing_hash(tmp_path: Path) -> None:
    store = CatalyticStore(tmp_path / "cas")

    with pytest.raises(ValueError):
        store.get_bytes("not-a-hash")

    with pytest.raises(ValueError):
        store.get_bytes("A" * 64)  # uppercase not allowed

    valid_missing = "0" * 64
    # Note: store.get_bytes(h) might raise a custom error or FileNotFoundError
    with pytest.raises((FileNotFoundError, ValueError)):
         store.get_bytes(valid_missing)

def test_normalize_relpath_accepts_and_normalizes() -> None:
    # normalize_relpath converts \ to /
    assert normalize_relpath(r"a\b\c") == "a/b/c"
    assert normalize_relpath("a/./b/./c") == "a/b/c"
    assert normalize_relpath("./a/b") == "a/b"
    assert normalize_relpath("a//b///c") == "a/b/c"
    assert normalize_relpath(".") == "."