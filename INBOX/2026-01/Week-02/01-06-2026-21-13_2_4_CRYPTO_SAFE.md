---
uuid: 00000000-0000-0000-0000-000000000000
title: CRYPTO_SAFE Packs and Protected Artifacts
section: report
bucket: reports/v4/section_2_4
author: System
priority: High
created: 2026-01-06 21:13
modified: 2026-02-03 12:00
status: Active
summary: 'V4 roadmap report: CRYPTO_SAFE Packs and Protected Artifacts'
tags:
- crypto
- v4
- roadmap
- report
---
<!-- CONTENT_HASH: 4c2bb15e21f767bd61a0666983205a11ae9b8fe9f7a5e3011497a72dd7414f27 -->

# Report: CRYPTO_SAFE Packs and Protected Artifacts

Date: 2026-01-05
Roadmap Section: 2.4

## Source inputs used
- REPORT_CRYPTO_HANDSHAKE_NEED.md
- ROADMAP_PHASE_CRYPTO_SAFE.md
- PROMPT_crypto_safe_implementation.md

## Goal
Provide cryptographic tamper-evidence to defend CCL v1.4 license provisions:
- Public code remains public.
- Meaning-bearing artifacts never ship in plaintext.
- Seal proves "I released this" - irrefutable authorship.
- Broken seal proves "you modified this" - license violation evidence.

This prevents "download equals extraction" for:
- vector indexes and embeddings
- CAS snapshots and deltas
- proof outputs that reveal protected plaintext or reconstruction inputs
- compression advantage artifacts

## License Defense Context

The seal provides cryptographic evidence to enforce these CCL v1.4 provisions:

| CCL Section | What It Prohibits | What Seal Proves |
|-------------|-------------------|------------------|
| **3.6** No Circumvention | Bypassing Access Controls on Protected Artifacts | "The encrypted artifacts I released have hash X - you have plaintext without attestation" |
| **3.7** No False Attestation | Submitting false Compliance Attestations | "I have no attestation record for you, yet you have decrypted content" |
| **4.4** Cryptographic Handshake | Access without signed attestation | "Protected Artifacts require attestation - here's proof of what I released" |

**The Defense Scenario:**
1. Someone claims: "I didn't circumvent anything"
2. You prove: "Here's the exact sealed state I released, signed by me"
3. You prove: "The Protected Artifacts I released were encrypted with hash X"
4. You prove: "You have plaintext but no attestation record from me"
5. Conclusion: "Section 3.6 violation - the seal was broken"

## Philosophy: Tamper-Evidence, Not Access Control

**CRITICAL DISTINCTION:** Crypto Safe is a detection system, not a prevention system.

| What Crypto Safe IS | What Crypto Safe is NOT |
|---------------------|-------------------------|
| Tamper-evidence ("you broke my seal") | Access control ("you cannot use this") |
| Proof of provenance ("I released this") | DRM or copy protection |
| License violation evidence | Permission management |
| Wax seal (proves opening, doesn't prevent it) | Lock (prevents access) |

**Core Principle:** Anyone can fork, modify, and use this repository. They simply cannot claim they received it unmodified from the original author. The seal proves authenticity, not exclusivity.

**Non-Goals:**
- NOT preventing access - no keys required to use the code
- NOT barring anyone from the repo - open source remains open source
- NOT DRM - no runtime checks, no phone-home, no license servers
- NOT key management - no automated key release infrastructure

The wax-seal analogy: breaking the seal doesn't prevent reading the letter, but it proves the envelope was opened.

## What Gets Sealed

**This repo IS the release.** No separate export step.

| Category | What | Sealed? |
|----------|------|---------|
| Framework Code | All tracked `.py`, `.md`, governance docs | YES - hashed + signed |
| License | CCL v1.4 | YES - in manifest |
| Protected Artifacts | Encrypted vectors, CAS, proofs | YES - encrypted form hashed |
| Manifest | `RELEASE_MANIFEST.json` + signature | YES - this IS the seal |

**NOT in repo** (gitignored, local only):
- Working vector databases
- Unencrypted CAS blobs
- Runtime artifacts

## Core definition
A pack is **crypto-safe** if:
1) It contains zero plaintext Protected Artifacts.
2) It includes manifests and receipts sufficient for integrity verification:
   - `PROTECTED_MANIFEST.json` (plaintext hashes computed locally pre-seal, ciphertext hashes, params)
   - `GREEN_STATE.json` (machine)
   - `PROOF_MANIFEST.json` (hashes/bytes of proof outputs)
3) Verification is mechanical and fail-closed.

## Placement rationale
This phase belongs immediately after pack/proofs capability because it governs distribution of value produced by the system.

## Policy objects
### A. Protected Artifacts Inventory
Canonical list of:
- artifact classes
- path patterns
- allowed locations (if any)
- distribution rules (plaintext allowed? ciphertext only?)

This must be a single source of truth. If inventory is incomplete, crypto-safe becomes theater.

### B. Enforcement matrix
Mapping: artifact class â†’ plaintext allowed? where? how sealed? how verified?

### C. Pack mode bindings
- Full: includes broad NAVIGATION, sealed artifacts, receipts.
- Split: includes dedicated PROOFS section, sealed artifacts, receipts.
- Lite: includes JSON summaries and hashes (typically no ciphertext blobs unless needed).

## Mechanics
### CRYPTO_SAFE.1 Hygiene
- `_PACK_RUN/` is always gitignored.
- Packer refuses to run if `_PACK_RUN/` is tracked.
- A scanner fails if protected patterns appear outside allowed locations.

### CRYPTO_SAFE.2 Sealing primitive
Implement sealing tool:
- Inputs: files/dirs from inventory.
- Outputs:
  - ciphertext blobs
  - `PROTECTED_MANIFEST.json` with deterministic ordering
  - bounded stdout/stderr digests (no secrets)
- Fail closed on any sealing error.

Encryption baseline:
- Prefer `age` or `gpg` if available locally.
- No network calls.
- No key material in logs, repo, or packs.

### CRYPTO_SAFE.3 Optional attestation
Optional offline signing:
- Attestation schema and verifier produce deterministic receipts and exit codes.
- No automated key release required for v1.

### CRYPTO_SAFE.4 Packer integration
During pack run:
- regenerate proofs fresh
- write run artifacts into pack output tree
- optionally mirror into `_PACK_RUN/LATEST/`
- seal protected artifacts
- include only ciphertext + manifests + receipts

### CRYPTO_SAFE.5 One-command verifier
Single command that checks:
- no plaintext protected artifacts in pack output
- no plaintext protected artifacts tracked by git
- manifests complete and consistent
- receipts present and valid hashes

## Tests
- Positive: crypto-safe pack contains ciphertext only for protected classes.
- Negative: plaintext protected artifact triggers hard fail with leak report.
- Determinism: stable manifest ordering/hashes on repeated runs with same inputs.

## Artifacts
Recommended proof area:
- `NAVIGATION/PROOFS/CRYPTO_SAFE/` reports that show:
  - inventory snapshot hash
  - scan outputs
  - sample pack directory structure (no sensitive plaintext)
  - verify command line and expected PASS/FAIL

## Risks
- Incomplete inventory.
- Sealing tool availability variance (Windows/WSL differences). Mitigate via clear prereqs and fail-closed checks.

## Acceptance criteria
- Public distribution contains no plaintext protected artifacts.
- Packs are verifiable without keys (integrity-only).
- Verification is mechanical and fail-closed.
