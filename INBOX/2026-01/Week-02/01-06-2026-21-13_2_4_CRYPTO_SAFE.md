---
uuid: 00000000-0000-0000-0000-000000000000
title: CRYPTO_SAFE Packs and Protected Artifacts
section: report
bucket: reports/v4/section_2_4
author: System
priority: High
created: 2026-01-06 21:13
modified: 2026-01-06 21:13
status: Active
summary: 'V4 roadmap report: CRYPTO_SAFE Packs and Protected Artifacts'
tags:
- crypto
- v4
- roadmap
- report
---
<!-- CONTENT_HASH: 4c2bb15e21f767bd61a0666983205a11ae9b8fe9f7a5e3011497a72dd7414f27 -->

# Report: CRYPTO_SAFE Packs and Protected Artifacts

Date: 2026-01-05
Roadmap Section: 2.4

## Source inputs used
- REPORT_CRYPTO_HANDSHAKE_NEED.md
- ROADMAP_PHASE_CRYPTO_SAFE.md
- PROMPT_crypto_safe_implementation.md

## Goal
Convert license intent into a mechanical capability boundary:
- Public code remains public.
- Meaning-bearing artifacts never ship in plaintext.
- Packs prove work occurred via receipts and manifests, even without decryption keys.

This prevents “download equals extraction” for:
- vector indexes and embeddings
- CAS snapshots and deltas
- proof outputs that reveal protected plaintext or reconstruction inputs
- compression advantage artifacts

## Core definition
A pack is **crypto-safe** if:
1) It contains zero plaintext Protected Artifacts.
2) It includes manifests and receipts sufficient for integrity verification:
   - `PROTECTED_MANIFEST.json` (plaintext hashes computed locally pre-seal, ciphertext hashes, params)
   - `GREEN_STATE.json` (machine)
   - `PROOF_MANIFEST.json` (hashes/bytes of proof outputs)
3) Verification is mechanical and fail-closed.

## Placement rationale
This phase belongs immediately after pack/proofs capability because it governs distribution of value produced by the system.

## Policy objects
### A. Protected Artifacts Inventory
Canonical list of:
- artifact classes
- path patterns
- allowed locations (if any)
- distribution rules (plaintext allowed? ciphertext only?)

This must be a single source of truth. If inventory is incomplete, crypto-safe becomes theater.

### B. Enforcement matrix
Mapping: artifact class → plaintext allowed? where? how sealed? how verified?

### C. Pack mode bindings
- Full: includes broad NAVIGATION, sealed artifacts, receipts.
- Split: includes dedicated PROOFS section, sealed artifacts, receipts.
- Lite: includes JSON summaries and hashes (typically no ciphertext blobs unless needed).

## Mechanics
### CRYPTO_SAFE.1 Hygiene
- `_PACK_RUN/` is always gitignored.
- Packer refuses to run if `_PACK_RUN/` is tracked.
- A scanner fails if protected patterns appear outside allowed locations.

### CRYPTO_SAFE.2 Sealing primitive
Implement sealing tool:
- Inputs: files/dirs from inventory.
- Outputs:
  - ciphertext blobs
  - `PROTECTED_MANIFEST.json` with deterministic ordering
  - bounded stdout/stderr digests (no secrets)
- Fail closed on any sealing error.

Encryption baseline:
- Prefer `age` or `gpg` if available locally.
- No network calls.
- No key material in logs, repo, or packs.

### CRYPTO_SAFE.3 Optional attestation
Optional offline signing:
- Attestation schema and verifier produce deterministic receipts and exit codes.
- No automated key release required for v1.

### CRYPTO_SAFE.4 Packer integration
During pack run:
- regenerate proofs fresh
- write run artifacts into pack output tree
- optionally mirror into `_PACK_RUN/LATEST/`
- seal protected artifacts
- include only ciphertext + manifests + receipts

### CRYPTO_SAFE.5 One-command verifier
Single command that checks:
- no plaintext protected artifacts in pack output
- no plaintext protected artifacts tracked by git
- manifests complete and consistent
- receipts present and valid hashes

## Tests
- Positive: crypto-safe pack contains ciphertext only for protected classes.
- Negative: plaintext protected artifact triggers hard fail with leak report.
- Determinism: stable manifest ordering/hashes on repeated runs with same inputs.

## Artifacts
Recommended proof area:
- `NAVIGATION/PROOFS/CRYPTO_SAFE/` reports that show:
  - inventory snapshot hash
  - scan outputs
  - sample pack directory structure (no sensitive plaintext)
  - verify command line and expected PASS/FAIL

## Risks
- Incomplete inventory.
- Sealing tool availability variance (Windows/WSL differences). Mitigate via clear prereqs and fail-closed checks.

## Acceptance criteria
- Public distribution contains no plaintext protected artifacts.
- Packs are verifiable without keys (integrity-only).
- Verification is mechanical and fail-closed.
