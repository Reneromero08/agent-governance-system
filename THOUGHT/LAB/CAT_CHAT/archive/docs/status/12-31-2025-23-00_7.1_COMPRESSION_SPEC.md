<!-- CONTENT_HASH: 391ab6823ab02831a21898e892fef0921396f0f2220d1f20e80a373d87311273 -->

# Phase 7: Compression Protocol Specification

**Version:** 1.0.0
**Status:** Final
**Date:** 2025-12-31

## 1. Overview

This specification defines the **compression protocol** for measuring and verifying token efficiency gains from using symbolic compression (Semiotic Compression Layer, SCL) instead of full-text transmission.

The protocol is **deterministic, bounded, and fail-closed**:
- Identical inputs produce identical outputs
- All metrics are computed from verified artifacts only
- Missing data, invalid attestations, or unbounded inputs result in explicit failures

## 2. Definitions

### 2.1 Compression Metric

**Compression Ratio** (`compression_ratio`): The ratio of compressed tokens to uncompressed tokens.

```
compression_ratio = compressed_tokens / uncompressed_tokens
```

Where:
- `uncompressed_tokens`: Estimated token count of full-text transmission (expanding all symbols)
- `compressed_tokens`: Actual token count of symbol-based transmission

**Units**: Dimensionless ratio (0 < compression_ratio <= 1)

**What is included**:
- All text content in artifacts (symbol refs, sections, slices)
- JSON structure overhead in receipts
- Symbol IDs themselves (@prefix:name notation)

**What is excluded**:
- Metadata (timestamps, paths, hashes)
- Signing keys, signatures
- Empty fields, null values

### 2.2 Component Definitions

#### 2.2.1 "vector_db_only"

**Input**: Full text embeddings of all referenced content without symbol substitution.

**Output**: Estimated token count for naive RAG approach.

**Computation**:
```
vector_db_tokens = sum(length(artifact.content) for artifact in artifacts)
```

Where `length()` counts UTF-8 characters (tokens are estimated via character count / 4).

#### 2.2.2 "symbol_lang"

**Input**: Symbol-based intermediate representation using @ID references.

**Output**: Actual token count of symbol-based transmission.

**Computation**:
```
symbol_lang_tokens = sum(length(artifact.symbol_refs) for artifact in artifacts) + sum(length(artifact.content) for artifact in artifacts where kind == "SECTION_SLICE")
```

Symbol refs are in format `@prefix:name` or `@ID`.

#### 2.2.3 "F3"

**Input**: Fractal compression using nested symbol references (theoretical).

**Output**: Estimated token count after applying fractal depth compression.

**Computation**:
```
f3_tokens = symbol_lang_tokens / fractal_depth_factor
```

Where `fractal_depth_factor` is empirically derived (default: 2.0).

**Note**: F3 is theoretical and not currently implemented. Claims with F3 enabled must fail with `NOT_IMPLEMENTED`.

#### 2.2.4 "CAS"

**Input**: Content-addressable storage references (hash-based).

**Output**: Minimal token count for hash-only transmission.

**Computation**:
```
cas_tokens = sum(length(artifact.sha256) for artifact in artifacts) + overhead_for_metadata
```

Where `overhead_for_metadata` includes JSON structure for mapping hashes to refs (default: 10 tokens per artifact).

### 2.3 Reconstruction Procedure

**Sufficient artifacts for reconstruction**:
1. Bundle manifest (`bundle.json`)
2. All artifact content files (in `artifacts/` directory)
3. Receipt chain for the run (all `run_id_*.json` receipts)
4. Trust policy for attestation verification (if attestations present)

**Reconstruction process**:
1. Verify bundle integrity (hashes, artifact content)
2. Verify receipt chain linkage (parent_receipt_hash matches)
3. Verify attestation signatures (if present)
4. Compute uncompressed tokens by expanding all symbol refs to their full content
5. Compute compressed tokens by counting symbol IDs directly
6. Compare with claimed metrics

## 3. Invariants (From Phase 6 Implementation)

### 3.1 Canonical JSON Rules

- JSON serialization uses `sort_keys=True, separators=(",", ":")`
- All JSON ends with exactly one newline (`\n`)
- No extra whitespace, no comments

### 3.2 Bundle ID Algorithm

```
pre_manifest = manifest.copy()
pre_manifest["bundle_id"] = ""
pre_manifest["hashes"]["root_hash"] = ""
bundle_id = SHA256(canonical_json(pre_manifest))
```

### 3.3 Receipt Signed Bytes Scope

Receipt signatures cover:
- Identity fields: `validator_id`, `build_id`, `public_key` (if present in attestation)
- Core receipt fields: `run_id`, `job_id`, `bundle_id`, `plan_hash`, `outcome`, `steps`, `artifacts`, `root_hash`, `parent_receipt_hash`
- Excluded from signature: `attestation.signature`, `receipt_hash`

### 3.4 Trust Policy Lookup Rules

- Primary lookup key: `validator_id` (if present in attestation)
- Fallback lookup key: `public_key` (if `validator_id` not present)
- Policy must have `enabled=true` for the validator
- Scope must match attestation type (`RECEIPT` or `MERKLE`)

### 3.5 Receipt Chain Semantics

- First receipt: `parent_receipt_hash = null`
- Subsequent receipts: `parent_receipt_hash = previous_receipt.receipt_hash`
- `receipt_index` must be strictly increasing by 1 if present
- `receipt_index = 0` for first receipt if indices are used

### 3.6 Merkle Root Computation

```
leaf_hashes = [receipt.receipt_hash for receipt in receipts]
merkle_root = compute_merkle_root(leaf_hashes)
```

Binary tree: H(i,j) = SHA256(H(i,mid) || H(mid+1,j))
Odd leaf is duplicated: H(n,n) = SHA256(H(n,n) || H(n,n))

### 3.7 Execution Policy Gate Semantics

Policy gates are checked **before** metric computation:
- `require_verify_chain`: If true, receipt chain must exist and verify
- `require_attestation`: If true, all receipts must have valid attestation
- `strict_trust`: If true, trust policy must be present and validator must be enabled
- `strict_identity`: If true, `build_id` must match trust policy entry

**Gate order** (fail-fast):
1. Load and parse trust policy (if `strict_trust` or `strict_identity`)
2. Verify bundle structure (schema, hashes)
3. Verify receipt chain (if `require_verify_chain`)
4. Verify attestations (if `require_attestation` or `strict_trust`)
5. Verify `build_id` pinning (if `strict_identity`)

## 4. Threat Model

### 4.1 What IS Proven

- Bundle integrity (artifact hashes match content)
- Receipt chain linkage (correct parent/child relationships)
- Attestation authenticity (signature verification against pinned keys)
- Metric reproducibility (deterministic computation from verified artifacts)

### 4.2 What is NOT Proven

- Correctness of uncompressed token estimation (character-based approximation)
- Semantic correctness of symbol expansion (ref lookup is trusted)
- Actual LLM token count (we estimate from character count)
- Fractal depth factor for F3 (empirical, not formally derived)
- Content authorship (attestations verify bundle integrity, not original authorship)

### 4.3 Out of Scope

- Validation of symbol registry integrity (assumed correct from bundle)
- Validation of section index correctness (assumed correct from bundle)
- Network transmission verification (offline verification only)
- Storage layer corruption detection (assumes artifact files are readable)

## 5. Verification Checklist

The validator must perform checks in this order (fail-fast):

### 5.1 Input Validation
- [ ] Bundle path exists and contains `bundle.json`
- [ ] Receipts directory exists (or policy allows missing receipts)
- [ ] Trust policy file exists (if `strict_trust` or `strict_identity`)
- [ ] Claim JSON file exists and is valid JSON

### 5.2 Schema Validation
- [ ] Claim matches `compression_claim.schema.json`
- [ ] Bundle matches `bundle.schema.json`
- [ ] Receipts match `receipt.schema.json` (if present)
- [ ] Trust policy matches `trust_policy.schema.json` (if present)

### 5.3 Bundle Verification
- [ ] Bundle ID recomputed correctly
- [ ] Root hash recomputed correctly
- [ ] Artifact content hashes match
- [ ] No forbidden `ALL` slices in artifacts
- [ ] All artifacts referenced by steps (boundedness check)
- [ ] No forbidden fields (timestamps, absolute paths)

### 5.4 Receipt Chain Verification (if `require_verify_chain`)
- [ ] All receipts found for run_id
- [ ] Receipts ordered by `receipt_index` or `receipt_hash`
- [ ] `parent_receipt_hash` linkage correct
- [ ] `receipt_hash` recomputed correctly for each receipt
- [ ] `receipt_index` contiguous if present

### 5.5 Attestation Verification (if `require_attestation` or `strict_trust`)
- [ ] All receipts have attestation (if `require_attestation`)
- [ ] Signature verification passes for each attestation
- [ ] Validator found in trust policy (if `strict_trust`)
- [ ] Validator `enabled=true` in trust policy
- [ ] Scope matches attestation type (`RECEIPT` or `MERKLE`)
- [ ] `build_id` matches trust policy (if `strict_identity`)

### 5.6 Merkle Attestation Verification (if `require_merkle_attestation`)
- [ ] Merkle root recomputed from receipt hashes
- [ ] Merkle attestation signature valid
- [ ] Merkle attestation scope includes `MERKLE`
- [ ] Merkle attestation `receipt_count` matches actual count
- [ ] Merkle attestation `receipt_chain_head_hash` matches last receipt

### 5.7 Metric Computation
- [ ] Uncompressed tokens computed from verified artifacts only
- [ ] Compressed tokens computed from verified artifacts only
- [ ] Component flags in claim match actual artifact composition
- [ ] F3 component fails with `NOT_IMPLEMENTED` (theoretical)

### 5.8 Claim Verification
- [ ] `compression_ratio` matches computed ratio
- [ ] `uncompressed_tokens` matches computed value
- [ ] `compressed_tokens` matches computed value
- [ ] Component counts match actual artifact counts
- [ ] No unexpected metrics in claim

## 6. Error Codes

| Code | Description | Phase |
|------|-------------|-------|
| `BUNDLE_NOT_FOUND` | Bundle directory or bundle.json missing | Input |
| `INVALID_BUNDLE_SCHEMA` | Bundle fails schema validation | Schema |
| `INVALID_CLAIM_SCHEMA` | Claim fails schema validation | Schema |
| `INVALID_RECEIPT_SCHEMA` | Receipt fails schema validation | Schema |
| `INVALID_TRUST_POLICY_SCHEMA` | Trust policy fails schema validation | Schema |
| `BUNDLE_ID_MISMATCH` | Bundle ID recomputation failed | Bundle |
| `ROOT_HASH_MISMATCH` | Root hash recomputation failed | Bundle |
| `ARTIFACT_HASH_MISMATCH` | Artifact content hash mismatch | Bundle |
| `FORBIDDEN_ALL_SLICE` | Artifact contains forbidden ALL slice | Bundle |
| `UNBOUNDED_ARTIFACT` | Artifact not referenced by steps (unbounded) | Bundle |
| `FORBIDDEN_FIELD` | Bundle contains forbidden field (timestamp, path) | Bundle |
| `RECEIPT_CHAIN_BROKEN` | Parent/child linkage broken | Receipt |
| `RECEIPT_HASH_MISMATCH` | Receipt hash recomputation failed | Receipt |
| `RECEIPT_INDEX_GAP` | Receipt index not contiguous | Receipt |
| `MISSING_RECEIPTS` | Receipts required but not found | Receipt |
| `ATTESTATION_MISSING` | Attestation required but missing | Attestation |
| `ATTESTATION_INVALID` | Signature verification failed | Attestation |
| `VALIDATOR_NOT_FOUND` | Validator not in trust policy | Trust |
| `VALIDATOR_DISABLED` | Validator not enabled in trust policy | Trust |
| `SCOPE_MISMATCH` | Validator scope doesn't match attestation type | Trust |
| `BUILD_ID_MISMATCH` | build_id doesn't match trust policy | Trust |
| `MERKLE_ROOT_MISMATCH` | Merkle root recomputation failed | Merkle |
| `MERKLE_ATTESTATION_INVALID` | Merkle attestation signature invalid | Merkle |
| `NOT_IMPLEMENTED` | Feature not implemented (e.g., F3) | Metric |
| `METRIC_MISMATCH` | Claimed metric doesn't match computed value | Metric |
| `COMPONENT_MISMATCH` | Component flag doesn't match artifacts | Metric |
| `INTERNAL_ERROR` | Unexpected internal error | System |

## 7. Deterministic Computation Rules

### 7.1 Token Estimation

Use character count / 4 as token approximation:
```
estimated_tokens = len(text.encode('utf-8')) / 4
```

Rounded to nearest integer using `round()`.

### 7.2 Artifact Ordering

Artifacts sorted by `artifact_id` (ascending).
This order is used for all metric computations.

### 7.3 Receipt Ordering

Receipts sorted by `receipt_index` (if present), then by `receipt_hash`.
This order is used for Merkle root computation.

### 7.4 Hash Computation

All hashes use SHA-256:
```
hash = hashlib.sha256(data).hexdigest()
```

Output is lowercase hex string (64 characters).

## 8. Fail-Closed Behavior

The validator **must fail** on:
- Any missing required field
- Any schema violation
- Any hash mismatch
- Any signature failure
- Any boundedness violation
- Any metric mismatch
- Any unexpected error

Exit codes:
- `0`: Verification passed
- `1`: Verification failed (metrics mismatch, policy violation)
- `2`: Invalid input (missing files, schema errors)
- `3`: Internal error (bug in validator code)

No silent failures. No "best effort" verification.
