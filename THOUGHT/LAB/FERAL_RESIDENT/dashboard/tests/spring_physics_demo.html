<!DOCTYPE html>
<html>
<head>
    <title>Spring Physics - Feral Constellation</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { background: #000; color: #0f0; font-family: monospace; overflow: hidden; }
        #container { width: 100vw; height: 100vh; }
        #controls {
            position: fixed; top: 20px; left: 20px;
            background: rgba(0,20,0,0.95); padding: 20px;
            border: 1px solid #0f0; z-index: 100; width: 280px;
        }
        .row { margin: 8px 0; display: flex; justify-content: space-between; align-items: center; }
        .row label { flex: 1; font-size: 12px; }
        .row input[type="range"] { width: 100px; }
        .row span { width: 45px; text-align: right; font-size: 11px; }
        button { background: #0f0; color: #000; border: none; padding: 8px 12px; cursor: pointer; margin: 3px; font-family: monospace; font-size: 11px; }
        button:hover { background: #0c0; }
        h3 { margin-bottom: 12px; border-bottom: 1px solid #0f0; padding-bottom: 8px; font-size: 14px; }
        #stats { position: fixed; top: 20px; right: 20px; background: rgba(0,20,0,0.95); padding: 12px; border: 1px solid #0f0; font-size: 12px; }
        #stats div { margin: 4px 0; }
        #loading { position: fixed; top: 50%; left: 50%; transform: translate(-50%,-50%); font-size: 18px; }
    </style>
</head>
<body>
    <div id="container"></div>
    <div id="loading">Loading constellation from feral_eternal.db...</div>
    <div id="controls" style="display:none;">
        <h3>FERAL CONSTELLATION</h3>
        <div class="row"><label>Spring K</label><input type="range" id="springK" min="0.01" max="0.2" step="0.005" value="0.05"><span id="v-springK">0.05</span></div>
        <div class="row"><label>Rest Length</label><input type="range" id="restLen" min="30" max="150" step="5" value="70"><span id="v-restLen">70</span></div>
        <div class="row"><label>Repulsion</label><input type="range" id="repel" min="20" max="400" step="10" value="120"><span id="v-repel">120</span></div>
        <div class="row"><label>Center Pull</label><input type="range" id="center" min="0.002" max="0.05" step="0.002" value="0.015"><span id="v-center">0.015</span></div>
        <div class="row"><label>Damping</label><input type="range" id="damp" min="0.88" max="0.98" step="0.01" value="0.93"><span id="v-damp">0.93</span></div>
        <div class="row"><label>Sim Threshold</label><input type="range" id="thresh" min="0.3" max="1.0" step="0.05" value="0.5"><span id="v-thresh">0.50</span></div>
        <div style="margin-top:12px;"><button onclick="reload()">Reload</button><button onclick="resetView()">Reset View</button></div>
    </div>
    <div id="stats" style="display:none;">
        <div>Nodes: <span id="s-nodes">0</span></div>
        <div>Edges: <span id="s-edges">0</span></div>
        <div>Similarity: <span id="s-sim">0</span></div>
        <div>Visible: <span id="s-visible">0</span></div>
    </div>

    <script type="importmap">
    { "imports": { "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js", "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/" } }
    </script>
    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

        // Config
        let cfg = { springK: 0.05, restLen: 70, repel: 120, center: 0.015, damp: 0.93, thresh: 0.5 };

        // Data
        let nodes = [], edges = [];
        const meshes = new Map(), lines = new Map();
        const nodeById = new Map();

        // Three.js
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x000508);
        scene.fog = new THREE.FogExp2(0x000508, 0.003);
        const camera = new THREE.PerspectiveCamera(60, innerWidth/innerHeight, 1, 3000);
        camera.position.set(0, 0, 400);
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(innerWidth, innerHeight);
        document.getElementById('container').appendChild(renderer.domElement);
        const ctrl = new OrbitControls(camera, renderer.domElement);
        ctrl.enableDamping = true;
        ctrl.dampingFactor = 0.08;

        // Materials
        const folderMat = new THREE.MeshBasicMaterial({ color: 0x00ff41 });
        const pageMat = new THREE.MeshBasicMaterial({ color: 0x008f11 });
        const folderGeo = new THREE.SphereGeometry(5, 12, 12);
        const pageGeo = new THREE.SphereGeometry(3, 10, 10);
        const hierMat = new THREE.LineBasicMaterial({ color: 0x004400, transparent: true, opacity: 0.3 });
        const simMat = new THREE.LineBasicMaterial({ color: 0x00ffff, transparent: true, opacity: 0.5 });

        async function loadConstellation() {
            try {
                const res = await fetch('http://localhost:8420/api/constellation?max_nodes=150');
                const data = await res.json();

                if (!data.ok) {
                    document.getElementById('loading').textContent = 'Error: ' + (data.error || 'Failed to load');
                    return;
                }

                // Clear existing
                for (const m of meshes.values()) scene.remove(m);
                for (const {line} of lines.values()) scene.remove(line);
                meshes.clear(); lines.clear(); nodes = []; edges = []; nodeById.clear();

                // Create nodes
                for (let i = 0; i < data.nodes.length; i++) {
                    const nd = data.nodes[i];
                    const n = {
                        id: nd.id,
                        idx: i,
                        label: nd.label,
                        group: nd.group,
                        x: (Math.random()-0.5)*200,
                        y: (Math.random()-0.5)*200,
                        z: (Math.random()-0.5)*200,
                        vx: 0, vy: 0, vz: 0,
                        fixed: nd.id === 'root'  // Root stays at center
                    };
                    if (n.fixed) { n.x = 0; n.y = 0; n.z = 0; }
                    nodes.push(n);
                    nodeById.set(nd.id, n);

                    const geo = nd.group === 'folder' ? folderGeo : pageGeo;
                    const mat = nd.group === 'folder' ? folderMat.clone() : pageMat.clone();
                    const m = new THREE.Mesh(geo, mat);
                    m.position.set(n.x, n.y, n.z);
                    scene.add(m);
                    meshes.set(nd.id, m);
                }

                // Create edges
                for (const ed of data.edges) {
                    const src = nodeById.get(ed.from);
                    const tgt = nodeById.get(ed.to);
                    if (!src || !tgt) continue;

                    const e = {
                        srcId: ed.from,
                        tgtId: ed.to,
                        type: ed.type || 'hierarchy',
                        weight: ed.weight || 0.5
                    };
                    edges.push(e);

                    const geo = new THREE.BufferGeometry();
                    geo.setAttribute('position', new THREE.Float32BufferAttribute([0,0,0,0,0,0], 3));
                    const mat = e.type === 'similarity' ? simMat.clone() : hierMat.clone();
                    const line = new THREE.Line(geo, mat);
                    scene.add(line);
                    lines.set(`${ed.from}-${ed.to}`, { line, edge: e });
                }

                document.getElementById('loading').style.display = 'none';
                document.getElementById('controls').style.display = 'block';
                document.getElementById('stats').style.display = 'block';

                document.getElementById('s-nodes').textContent = nodes.length;
                document.getElementById('s-edges').textContent = edges.length;
                document.getElementById('s-sim').textContent = edges.filter(e => e.type === 'similarity').length;

            } catch (err) {
                document.getElementById('loading').textContent = 'Error: ' + err.message + '\n\nMake sure feral server is running on port 8420';
            }
        }

        function physics() {
            const { springK, restLen, repel, center, damp, thresh } = cfg;

            for (const n of nodes) {
                if (n.fixed) continue;

                let fx = 0, fy = 0, fz = 0;

                // Springs from edges
                for (const e of edges) {
                    // Skip similarity edges below threshold
                    if (e.type === 'similarity' && e.weight < thresh) continue;

                    let o = null;
                    if (e.srcId === n.id) o = nodeById.get(e.tgtId);
                    else if (e.tgtId === n.id) o = nodeById.get(e.srcId);
                    else continue;
                    if (!o) continue;

                    const dx = o.x - n.x, dy = o.y - n.y, dz = o.z - n.z;
                    const d = Math.sqrt(dx*dx + dy*dy + dz*dz) || 0.1;

                    // Stronger springs for higher similarity
                    const k = e.type === 'similarity' ? springK * e.weight * 1.5 : springK * 0.5;
                    const targetLen = e.type === 'similarity' ? restLen * (1.5 - e.weight) : restLen * 0.7;
                    const f = k * (d - targetLen);

                    fx += (dx/d) * f;
                    fy += (dy/d) * f;
                    fz += (dz/d) * f;
                }

                // Repulsion from nearby nodes
                for (const o of nodes) {
                    if (o.id === n.id) continue;
                    const dx = n.x - o.x, dy = n.y - o.y, dz = n.z - o.z;
                    const d2 = dx*dx + dy*dy + dz*dz || 1;
                    if (d2 > 40000) continue;  // Skip far nodes
                    const d = Math.sqrt(d2);
                    const f = Math.min(repel / d2, 2);
                    fx += (dx/d) * f;
                    fy += (dy/d) * f;
                    fz += (dz/d) * f;
                }

                // Center pull
                fx -= n.x * center;
                fy -= n.y * center;
                fz -= n.z * center;

                // Integrate with damping
                n.vx = (n.vx + fx) * damp;
                n.vy = (n.vy + fy) * damp;
                n.vz = (n.vz + fz) * damp;
                n.x += n.vx;
                n.y += n.vy;
                n.z += n.vz;
            }

            // Update meshes
            for (const n of nodes) {
                const m = meshes.get(n.id);
                if (m) m.position.set(n.x, n.y, n.z);
            }

            // Update lines
            let vis = 0;
            for (const [k, {line, edge}] of lines) {
                const s = nodeById.get(edge.srcId);
                const t = nodeById.get(edge.tgtId);
                if (!s || !t) continue;

                const pos = line.geometry.attributes.position.array;
                pos[0] = s.x; pos[1] = s.y; pos[2] = s.z;
                pos[3] = t.x; pos[4] = t.y; pos[5] = t.z;
                line.geometry.attributes.position.needsUpdate = true;

                if (edge.type === 'similarity') {
                    const show = edge.weight >= cfg.thresh;
                    line.visible = show;
                    line.material.opacity = show ? 0.2 + edge.weight * 0.6 : 0;
                    if (show) vis++;
                } else {
                    line.visible = true;
                }
            }
            document.getElementById('s-visible').textContent = vis;
        }

        function animate() {
            requestAnimationFrame(animate);
            ctrl.update();
            physics();
            renderer.render(scene, camera);
        }

        // Slider bindings
        const sliders = [
            ['springK', 'v-springK', 3], ['restLen', 'v-restLen', 0], ['repel', 'v-repel', 0],
            ['center', 'v-center', 3], ['damp', 'v-damp', 2], ['thresh', 'v-thresh', 2]
        ];
        for (const [id, vId, dec] of sliders) {
            document.getElementById(id).oninput = e => {
                cfg[id] = parseFloat(e.target.value);
                document.getElementById(vId).textContent = cfg[id].toFixed(dec);
            };
        }

        window.reload = loadConstellation;
        window.resetView = () => {
            camera.position.set(0, 0, 400);
            ctrl.target.set(0, 0, 0);
        };

        window.onresize = () => {
            camera.aspect = innerWidth/innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(innerWidth, innerHeight);
        };

        // Start
        loadConstellation();
        animate();
    </script>
</body>
</html>
