<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>FERAL // Autonomous Resident</title>
    <!-- Fonts -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&family=JetBrains+Mono:wght@400;500&display=swap" rel="stylesheet">
    <!-- Three.js + 3D Force Graph (async loading) -->
    <script async src="https://unpkg.com/three@0.160.0/build/three.min.js"></script>
    <script async src="https://unpkg.com/d3-force-3d@3.0.5/dist/d3-force-3d.min.js"></script>
    <script async src="https://unpkg.com/3d-force-graph@1.73.0/dist/3d-force-graph.min.js"></script>
    <style>
        :root {
            --bg-primary: #000000;
            --bg-secondary: #0a0a0a;
            --bg-tertiary: #111111;
            --bg-elevated: #1a1a1a;
            --border: #222222;
            --border-subtle: #1a1a1a;
            --text-primary: #ffffff;
            --text-secondary: #888888;
            --text-muted: #555555;
            --accent: #00ff41;
            --accent-dim: #00cc33;
            --accent-subtle: rgba(0, 255, 65, 0.1);
            --danger: #ff4444;
            --sidebar-width: 280px;
            --activity-height: 56px;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body, html {
            width: 100%;
            height: 100%;
            background: var(--bg-primary);
            color: var(--text-primary);
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, sans-serif;
            overflow: hidden;
        }

        /* ===== LAYOUT ===== */
        .app {
            display: grid;
            grid-template-rows: 1fr var(--activity-height);
            grid-template-columns: var(--sidebar-width) 1fr;
            grid-template-areas:
                "sidebar canvas"
                "activity activity";
            height: 100vh;
        }

        .app.sidebar-collapsed {
            grid-template-columns: 40px 1fr;
        }

        .app.sidebar-collapsed .sidebar-content {
            display: none;
        }

        .app.sidebar-collapsed .sidebar-title {
            display: none;
        }

        .app.sidebar-collapsed .sidebar-toggle {
            transform: rotate(180deg);
        }

        .app.sidebar-collapsed .sidebar-header {
            justify-content: center;
        }

        /* ===== SIDEBAR ===== */
        .sidebar {
            grid-area: sidebar;
            background: var(--bg-secondary);
            border-right: 1px solid var(--border);
            overflow-y: auto;
            overflow-x: hidden;
            display: flex;
            flex-direction: column;
        }

        .sidebar-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 12px 16px;
            border-bottom: 1px solid var(--border);
        }

        .sidebar-title {
            font-size: 12px;
            font-weight: 600;
            letter-spacing: 2px;
            color: var(--accent);
        }

        .sidebar-toggle {
            width: 24px;
            height: 24px;
            background: transparent;
            border: none;
            color: var(--text-muted);
            cursor: pointer;
            font-size: 14px;
        }

        .sidebar-toggle:hover {
            color: var(--text-primary);
        }

        .sidebar-content {
            flex: 1;
            overflow-y: auto;
        }

        .sidebar::-webkit-scrollbar,
        .sidebar-content::-webkit-scrollbar {
            width: 4px;
        }

        .sidebar::-webkit-scrollbar-track,
        .sidebar-content::-webkit-scrollbar-track {
            background: transparent;
        }

        .sidebar::-webkit-scrollbar-thumb,
        .sidebar-content::-webkit-scrollbar-thumb {
            background: var(--border);
            border-radius: 2px;
        }

        /* Accordion Section */
        .section {
            border-bottom: 1px solid var(--border-subtle);
        }

        .section-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 14px 16px;
            cursor: pointer;
            user-select: none;
        }

        .section-header:hover {
            background: var(--bg-tertiary);
        }

        .section-title {
            font-size: 11px;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 1px;
            color: var(--text-secondary);
        }

        .section-chevron {
            font-size: 10px;
            color: var(--text-muted);
        }

        .section.collapsed .section-chevron {
            transform: rotate(-90deg);
        }

        .section.collapsed .section-content {
            display: none;
        }

        .section-content {
            padding: 0 16px 16px;
        }

        /* Mind State */
        .stat-card {
            background: var(--bg-tertiary);
            border-radius: 8px;
            padding: 12px;
            margin-bottom: 8px;
        }

        .stat-label {
            font-size: 10px;
            color: var(--text-muted);
            text-transform: uppercase;
            letter-spacing: 0.5px;
            margin-bottom: 4px;
        }

        .stat-value {
            font-family: 'JetBrains Mono', monospace;
            font-size: 24px;
            font-weight: 500;
            color: var(--accent);
        }

        .stat-unit {
            font-size: 12px;
            color: var(--text-muted);
            margin-left: 4px;
        }

        .progress-bar {
            height: 4px;
            background: var(--bg-elevated);
            border-radius: 2px;
            margin-top: 8px;
            overflow: hidden;
        }

        .progress-fill {
            height: 100%;
            background: var(--accent);
            border-radius: 2px;
        }

        .stat-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 8px 0;
            border-bottom: 1px solid var(--border-subtle);
        }

        .stat-row:last-child {
            border-bottom: none;
        }

        .stat-row-label {
            font-size: 12px;
            color: var(--text-secondary);
        }

        .stat-row-value {
            font-family: 'JetBrains Mono', monospace;
            font-size: 12px;
            color: var(--text-primary);
        }

        .sparkline {
            display: flex;
            align-items: flex-end;
            gap: 1px;
            height: 32px;
            margin-top: 8px;
        }

        .spark-bar {
            flex: 1;
            background: var(--accent);
            min-height: 2px;
            opacity: 0.6;
            border-radius: 1px;
        }

        /* Daemon Controls */
        .daemon-status {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 12px;
        }

        .daemon-state {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .daemon-led {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: var(--text-muted);
        }

        .daemon-led.on {
            background: var(--accent);
            box-shadow: 0 0 8px var(--accent);
        }

        .daemon-label {
            font-size: 12px;
            font-weight: 500;
        }

        .daemon-btn {
            padding: 6px 12px;
            font-size: 11px;
            font-weight: 500;
            border: 1px solid var(--border);
            background: transparent;
            color: var(--text-secondary);
            border-radius: 4px;
            cursor: pointer;
        }

        .daemon-btn:hover {
            background: var(--bg-elevated);
            color: var(--text-primary);
        }

        .daemon-btn.primary {
            background: var(--accent);
            border-color: var(--accent);
            color: var(--bg-primary);
        }

        .daemon-btn.primary:hover {
            background: var(--accent-dim);
        }

        .behavior-item {
            display: flex;
            align-items: center;
            padding: 10px 0;
            border-bottom: 1px solid var(--border-subtle);
        }

        .behavior-item:last-child {
            border-bottom: none;
        }

        .behavior-toggle {
            width: 36px;
            height: 20px;
            background: #333;
            border: 1px solid var(--border);
            border-radius: 10px;
            position: relative;
            cursor: pointer;
            transition: background 0.2s ease;
        }

        .behavior-toggle.on {
            background: var(--accent);
            border-color: var(--accent);
        }

        .behavior-toggle::after {
            content: '';
            position: absolute;
            width: 14px;
            height: 14px;
            background: white;
            border-radius: 50%;
            top: 2px;
            left: 2px;
            transition: left 0.2s ease;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.3);
        }

        .behavior-toggle.on::after {
            left: 18px;
        }

        .behavior-info {
            flex: 1;
            margin-left: 12px;
        }

        .behavior-name {
            font-size: 12px;
            font-weight: 500;
            margin-bottom: 2px;
        }

        .behavior-interval {
            font-size: 10px;
            color: var(--text-muted);
        }

        .behavior-input {
            width: 48px;
            padding: 4px 6px;
            font-family: 'JetBrains Mono', monospace;
            font-size: 11px;
            background: var(--bg-elevated);
            border: 1px solid var(--border);
            border-radius: 4px;
            color: var(--text-primary);
            text-align: right;
        }

        .behavior-input:focus {
            outline: none;
            border-color: var(--accent);
        }

        /* Graph Settings */
        .slider-row {
            display: flex;
            align-items: center;
            padding: 10px 0;
        }

        .slider-label {
            width: 80px;
            font-size: 11px;
            color: var(--text-secondary);
        }

        .slider-container {
            flex: 1;
            margin: 0 12px;
        }

        input[type="range"] {
            -webkit-appearance: none;
            appearance: none;
            width: 100%;
            height: 4px;
            background: var(--bg-elevated);
            border-radius: 2px;
            outline: none;
            cursor: pointer;
        }

        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 14px;
            height: 14px;
            background: var(--accent);
            border-radius: 50%;
            cursor: pointer;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.5);
        }

        input[type="range"]::-moz-range-thumb {
            width: 14px;
            height: 14px;
            background: var(--accent);
            border: none;
            border-radius: 50%;
            cursor: pointer;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.5);
        }

        input[type="range"]::-moz-range-track {
            height: 4px;
            background: var(--bg-elevated);
            border-radius: 2px;
        }

        .slider-value {
            width: 40px;
            font-family: 'JetBrains Mono', monospace;
            font-size: 10px;
            color: var(--text-muted);
            text-align: right;
        }

        .reset-btn {
            width: 100%;
            padding: 8px;
            font-size: 11px;
            font-weight: 500;
            background: transparent;
            border: 1px solid var(--border);
            border-radius: 4px;
            color: var(--text-secondary);
            cursor: pointer;
            margin-top: 8px;
        }

        .reset-btn:hover {
            background: var(--bg-elevated);
            color: var(--text-primary);
        }

        /* ===== 3D CANVAS ===== */
        .canvas-container {
            grid-area: canvas;
            position: relative;
            background: var(--bg-primary);
        }

        #constellation-background {
            width: 100%;
            height: 100%;
        }

        #constellation-background canvas {
            width: 100% !important;
            height: 100% !important;
        }

        /* Node Tooltip */
        #node-tooltip {
            position: fixed;
            display: none;
            background: var(--bg-elevated);
            border: 1px solid var(--border);
            border-radius: 6px;
            padding: 8px 12px;
            font-size: 12px;
            z-index: 1000;
            pointer-events: none;
            max-width: 280px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.5);
        }

        #node-tooltip strong {
            color: var(--accent);
        }

        /* ===== ACTIVITY BAR ===== */
        .activity-bar {
            grid-area: activity;
            background: var(--bg-secondary);
            border-top: 1px solid var(--border);
            display: flex;
            align-items: center;
            padding: 0 16px;
            overflow: hidden;
            min-height: var(--activity-height);
            max-height: var(--activity-height);
        }

        .activity-label {
            font-size: 10px;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 1px;
            color: var(--text-muted);
            margin-right: 16px;
            white-space: nowrap;
        }

        .activity-feed {
            flex: 1;
            display: flex;
            align-items: center;
            gap: 16px;
            overflow-x: auto;
        }

        .activity-feed::-webkit-scrollbar {
            display: none;
        }

        .activity-item {
            display: flex;
            align-items: center;
            gap: 8px;
            white-space: nowrap;
        }

        .activity-badge {
            font-size: 9px;
            font-weight: 600;
            text-transform: uppercase;
            padding: 2px 6px;
            border-radius: 3px;
            background: var(--accent-subtle);
            color: var(--accent);
        }

        .activity-badge.error {
            background: rgba(255, 68, 68, 0.2);
            color: var(--danger);
        }

        .activity-badge.smash {
            background: rgba(255, 102, 0, 0.2);
            color: #ff6600;
        }

        .activity-badge.smasher {
            background: rgba(255, 102, 0, 0.3);
            color: #ff6600;
            font-weight: 700;
        }

        .activity-text {
            font-size: 11px;
            color: var(--text-secondary);
        }

        .activity-time {
            font-family: 'JetBrains Mono', monospace;
            font-size: 10px;
            color: var(--text-muted);
        }

        /* ===== CHAT SLIDE-OUT ===== */
        .chat-toggle {
            position: fixed;
            bottom: calc(var(--activity-height) + 20px);
            right: 20px;
            width: 48px;
            height: 48px;
            background: var(--accent);
            border: none;
            border-radius: 50%;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: 0 4px 12px rgba(0, 255, 65, 0.3);
            z-index: 200;
        }

        .chat-toggle:hover {
            background: var(--accent-dim);
        }

        .chat-toggle svg {
            width: 24px;
            height: 24px;
            fill: var(--bg-primary);
        }

        .chat-panel {
            position: fixed;
            top: 0;
            right: -400px;
            width: 400px;
            height: calc(100vh - var(--activity-height));
            background: var(--bg-secondary);
            border-left: 1px solid var(--border);
            z-index: 150;
            display: flex;
            flex-direction: column;
        }

        .chat-panel.open {
            right: 0;
        }

        .chat-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 16px;
            border-bottom: 1px solid var(--border);
        }

        .chat-title {
            font-size: 14px;
            font-weight: 600;
        }

        .chat-close {
            width: 28px;
            height: 28px;
            background: transparent;
            border: none;
            color: var(--text-muted);
            cursor: pointer;
            border-radius: 4px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 18px;
        }

        .chat-close:hover {
            background: var(--bg-tertiary);
            color: var(--text-primary);
        }

        .chat-messages {
            flex: 1;
            overflow-y: auto;
            padding: 16px;
        }

        .chat-messages::-webkit-scrollbar {
            width: 4px;
        }

        .chat-messages::-webkit-scrollbar-thumb {
            background: var(--border);
            border-radius: 2px;
        }

        .chat-msg {
            margin-bottom: 16px;
        }

        .chat-msg.user .chat-bubble {
            background: var(--bg-elevated);
            margin-left: 40px;
        }

        .chat-msg.feral .chat-bubble {
            background: var(--accent-subtle);
            border: 1px solid rgba(0, 255, 65, 0.2);
            margin-right: 40px;
        }

        .chat-bubble {
            padding: 12px;
            border-radius: 8px;
            font-size: 13px;
            line-height: 1.5;
        }

        .chat-meta {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-bottom: 6px;
            font-size: 11px;
        }

        .chat-sender {
            font-weight: 600;
            color: var(--text-secondary);
        }

        .chat-msg.feral .chat-sender {
            color: var(--accent);
        }

        .chat-e-badge {
            font-family: 'JetBrains Mono', monospace;
            font-size: 10px;
            padding: 2px 6px;
            border-radius: 3px;
        }

        .chat-e-badge.open {
            background: var(--accent-subtle);
            color: var(--accent);
        }

        .chat-e-badge.closed {
            background: rgba(255, 68, 68, 0.1);
            color: var(--danger);
        }

        .chat-input-area {
            padding: 16px;
            border-top: 1px solid var(--border);
        }

        .chat-input-row {
            display: flex;
            gap: 8px;
        }

        .chat-input {
            flex: 1;
            padding: 12px;
            font-size: 13px;
            background: var(--bg-tertiary);
            border: 1px solid var(--border);
            border-radius: 8px;
            color: var(--text-primary);
            outline: none;
            font-family: inherit;
        }

        .chat-input:focus {
            border-color: var(--accent);
        }

        .chat-input::placeholder {
            color: var(--text-muted);
        }

        .chat-send {
            padding: 12px 20px;
            background: var(--accent);
            border: none;
            border-radius: 8px;
            color: var(--bg-primary);
            font-weight: 600;
            font-size: 13px;
            cursor: pointer;
        }

        .chat-send:hover {
            background: var(--accent-dim);
        }

        /* ===== LOADING ===== */
        #loading {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: var(--bg-primary);
            display: flex;
            align-items: center;
            justify-content: center;
            flex-direction: column;
            z-index: 9999;
        }

        #loading.hidden {
            display: none;
        }

        .loading-spinner {
            width: 40px;
            height: 40px;
            border: 3px solid var(--border);
            border-top-color: var(--accent);
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .loading-text {
            margin-top: 16px;
            font-size: 12px;
            color: var(--text-muted);
        }

        /* Status indicators */
        .ws-status {
            display: flex;
            align-items: center;
            gap: 6px;
            font-size: 10px;
            color: var(--text-muted);
            padding: 8px 16px;
            border-bottom: 1px solid var(--border-subtle);
        }

        .ws-dot {
            width: 6px;
            height: 6px;
            border-radius: 50%;
            background: var(--accent);
        }

        .ws-dot.offline {
            background: var(--danger);
        }

        /* Smasher-specific styles */
        #smasher-stats .stat-value {
            color: #ff6600;
        }

        #smasher-led.on {
            background: #ff6600;
            box-shadow: 0 0 12px #ff6600;
            animation: smasher-pulse 0.5s ease-in-out infinite alternate;
        }

        @keyframes smasher-pulse {
            from { box-shadow: 0 0 8px #ff6600; }
            to { box-shadow: 0 0 16px #ff6600, 0 0 24px #ff4400; }
        }

        #smasher-status-text {
            font-family: 'JetBrains Mono', monospace;
        }

        /* Smasher current file indicator in activity bar - PROMINENT */
        .smasher-current {
            display: none;
            align-items: center;
            gap: 10px;
            padding: 6px 16px;
            background: rgba(255, 102, 0, 0.2);
            border: 1px solid rgba(255, 102, 0, 0.5);
            border-radius: 4px;
            margin-right: 12px;
            font-family: 'JetBrains Mono', monospace;
            animation: smasher-status-pulse 0.8s ease-in-out infinite alternate;
            flex-shrink: 0;
        }

        @keyframes smasher-status-pulse {
            from { background: rgba(255, 102, 0, 0.2); border-color: rgba(255, 102, 0, 0.5); }
            to { background: rgba(255, 102, 0, 0.35); border-color: rgba(255, 102, 0, 0.8); }
        }

        .smasher-current.active {
            display: flex;
        }

        .smasher-current-label {
            font-size: 9px;
            font-weight: 700;
            color: #ff6600;
            letter-spacing: 1px;
            text-shadow: 0 0 10px rgba(255, 102, 0, 0.7);
        }

        .smasher-current-file {
            font-size: 12px;
            font-weight: 600;
            color: #ffffff;
            max-width: 300px;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }

        .smasher-current-e {
            font-size: 10px;
            font-weight: 700;
            padding: 2px 8px;
            border-radius: 3px;
        }

        .smasher-current-e.open {
            background: rgba(0, 255, 65, 0.4);
            color: #00ff41;
            text-shadow: 0 0 8px rgba(0, 255, 65, 0.7);
        }

        .smasher-current-e.closed {
            background: rgba(255, 68, 68, 0.4);
            color: #ff4444;
            text-shadow: 0 0 8px rgba(255, 68, 68, 0.7);
        }
    </style>
</head>

<body>
    <!-- Loading -->
    <div id="loading">
        <div class="loading-spinner"></div>
        <div class="loading-text">Initializing Feral...</div>
    </div>

    <div class="app" id="app">
        <!-- Sidebar -->
        <aside class="sidebar">
            <div class="sidebar-header">
                <span class="sidebar-title">FERAL</span>
                <button class="sidebar-toggle" id="sidebar-toggle" onclick="toggleSidebar()">&#9664;</button>
            </div>

            <div class="sidebar-content">
                <!-- WebSocket Status -->
                <div class="ws-status">
                    <div class="ws-dot" id="ws-dot"></div>
                    <span id="ws-status-text">Connecting...</span>
                </div>

                <!-- Mind State Section -->
                <div class="section" id="section-mind">
                    <div class="section-header" onclick="toggleSection('mind')">
                        <span class="section-title">Mind State</span>
                        <span class="section-chevron">&#9660;</span>
                    </div>
                    <div class="section-content">
                        <div class="stat-card">
                            <div class="stat-label">Participation Ratio (Df)</div>
                            <div style="display: flex; align-items: baseline;">
                                <span class="stat-value" id="mind-df">0.0</span>
                                <span class="stat-unit">/ 256</span>
                            </div>
                            <div class="progress-bar">
                                <div class="progress-fill" id="df-progress" style="width: 0%"></div>
                            </div>
                        </div>
                        <div class="stat-row">
                            <span class="stat-row-label">Distance from Start</span>
                            <span class="stat-row-value"><span id="mind-distance">0.000</span> rad</span>
                        </div>
                        <div class="stat-row">
                            <span class="stat-row-label">Interactions</span>
                            <span class="stat-row-value" id="mind-interactions">0</span>
                        </div>
                        <div class="stat-label" style="margin-top: 12px;">Evolution</div>
                        <div class="sparkline" id="df-sparkline"></div>
                    </div>
                </div>

                <!-- Daemon Section -->
                <div class="section" id="section-daemon">
                    <div class="section-header" onclick="toggleSection('daemon')">
                        <span class="section-title">Daemon</span>
                        <span class="section-chevron">&#9660;</span>
                    </div>
                    <div class="section-content">
                        <div class="daemon-status">
                            <div class="daemon-state">
                                <div class="daemon-led" id="daemon-led"></div>
                                <span class="daemon-label" id="daemon-status-text">Stopped</span>
                            </div>
                            <button class="daemon-btn" id="daemon-toggle-btn" onclick="toggleDaemon()">Start</button>
                        </div>

                        <div class="behavior-item">
                            <div class="behavior-toggle" id="toggle-consolidate" onclick="toggleBehavior('memory_consolidation')"></div>
                            <div class="behavior-info">
                                <div class="behavior-name">Memory Consolidation</div>
                                <div class="behavior-interval">Find patterns</div>
                            </div>
                            <input type="number" class="behavior-input" id="input-consolidate" value="120" min="10" max="3600" onchange="updateInterval('memory_consolidation', this.value)">
                        </div>

                        <div class="behavior-item">
                            <div class="behavior-toggle" id="toggle-reflect" onclick="toggleBehavior('self_reflection')"></div>
                            <div class="behavior-info">
                                <div class="behavior-name">Self-Reflection</div>
                                <div class="behavior-interval">Generate questions</div>
                            </div>
                            <input type="number" class="behavior-input" id="input-reflect" value="60" min="10" max="3600" onchange="updateInterval('self_reflection', this.value)">
                        </div>

                        <div class="behavior-item">
                            <div class="behavior-toggle" id="toggle-cassette" onclick="toggleBehavior('cassette_watch')"></div>
                            <div class="behavior-info">
                                <div class="behavior-name">Cassette Watch</div>
                                <div class="behavior-interval">Monitor content</div>
                            </div>
                            <input type="number" class="behavior-input" id="input-cassette" value="15" min="5" max="600" onchange="updateInterval('cassette_watch', this.value)">
                        </div>
                    </div>
                </div>

                <!-- Particle Smasher Section -->
                <div class="section" id="section-smasher">
                    <div class="section-header" onclick="toggleSection('smasher')">
                        <span class="section-title">Particle Smasher</span>
                        <span class="section-chevron">&#9660;</span>
                    </div>
                    <div class="section-content">
                        <div class="daemon-status">
                            <div class="daemon-state">
                                <div class="daemon-led" id="smasher-led"></div>
                                <span class="daemon-label" id="smasher-status-text">Idle</span>
                            </div>
                            <button class="daemon-btn primary" id="smasher-toggle-btn" onclick="toggleSmasher()">SMASH</button>
                        </div>

                        <div class="stat-card" id="smasher-stats" style="display: none;">
                            <div class="stat-label">Throughput</div>
                            <div style="display: flex; align-items: baseline;">
                                <span class="stat-value" id="smasher-rate">0.0</span>
                                <span class="stat-unit">chunks/sec</span>
                            </div>
                            <div class="stat-row">
                                <span class="stat-row-label">Processed</span>
                                <span class="stat-row-value" id="smasher-processed">0</span>
                            </div>
                            <div class="stat-row">
                                <span class="stat-row-label">Absorbed</span>
                                <span class="stat-row-value" style="color: var(--accent)" id="smasher-absorbed">0</span>
                            </div>
                            <div class="stat-row">
                                <span class="stat-row-label">Rejected</span>
                                <span class="stat-row-value" style="color: var(--danger)" id="smasher-rejected">0</span>
                            </div>
                        </div>

                        <div class="slider-row">
                            <span class="slider-label">Speed</span>
                            <div class="slider-container">
                                <input type="range" id="slider-smasher-speed" min="10" max="2000" value="100" oninput="updateSmasherSpeed(this.value)">
                            </div>
                            <span class="slider-value" id="value-smasher-speed">100ms</span>
                        </div>

                        <div class="slider-row">
                            <span class="slider-label">Batch</span>
                            <div class="slider-container">
                                <input type="range" id="slider-smasher-batch" min="1" max="50" value="10" oninput="updateSmasherBatch(this.value)">
                            </div>
                            <span class="slider-value" id="value-smasher-batch">10</span>
                        </div>

                        <div class="slider-row">
                            <span class="slider-label">E Gate</span>
                            <div class="slider-container">
                                <input type="range" id="slider-e-threshold" min="0" max="100" value="30" oninput="updateEThreshold(this.value)">
                            </div>
                            <span class="slider-value" id="value-e-threshold">0.30</span>
                        </div>

                        <div class="behavior-item">
                            <div class="behavior-toggle on" id="toggle-static-camera" onclick="toggleStaticCamera()"></div>
                            <div class="behavior-info">
                                <div class="behavior-name">Static Camera</div>
                                <div class="behavior-interval">No auto-follow</div>
                            </div>
                        </div>

                    </div>
                </div>

                <!-- Graph Settings Section -->
                <div class="section" id="section-graph">
                    <div class="section-header" onclick="toggleSection('graph')">
                        <span class="section-title">Graph</span>
                        <span class="section-chevron">&#9660;</span>
                    </div>
                    <div class="section-content">
                        <div class="behavior-item">
                            <div class="behavior-toggle on" id="toggle-similarity" onclick="toggleSimilarityLinks()"></div>
                            <div class="behavior-info">
                                <div class="behavior-name">Similarity Links</div>
                                <div class="behavior-interval">Cosine similarity edges</div>
                            </div>
                        </div>

                        <div class="slider-row">
                            <span class="slider-label">Sim Threshold</span>
                            <div class="slider-container">
                                <input type="range" id="slider-sim-threshold" min="50" max="95" value="70" oninput="updateSimThreshold(this.value)">
                            </div>
                            <span class="slider-value" id="value-sim-threshold">0.70</span>
                        </div>

                        <div class="slider-row">
                            <span class="slider-label">Fog</span>
                            <div class="slider-container">
                                <input type="range" id="slider-fog" min="0" max="100" value="30" oninput="updateFog(this.value)">
                            </div>
                            <span class="slider-value" id="value-fog">0.003</span>
                        </div>

                        <div class="slider-row">
                            <span class="slider-label">Center</span>
                            <div class="slider-container">
                                <input type="range" id="slider-center" min="0" max="100" value="5" oninput="updateGraphForce('center', this.value)">
                            </div>
                            <span class="slider-value" id="value-center">0.05</span>
                        </div>

                        <div class="slider-row">
                            <span class="slider-label">Repel</span>
                            <div class="slider-container">
                                <input type="range" id="slider-repel" min="0" max="500" value="120" oninput="updateGraphForce('repel', this.value)">
                            </div>
                            <span class="slider-value" id="value-repel">-120</span>
                        </div>

                        <div class="slider-row">
                            <span class="slider-label">Link Force</span>
                            <div class="slider-container">
                                <input type="range" id="slider-link-strength" min="0" max="100" value="50" oninput="updateGraphForce('linkStrength', this.value)">
                            </div>
                            <span class="slider-value" id="value-link-strength">0.50</span>
                        </div>

                        <div class="slider-row">
                            <span class="slider-label">Distance</span>
                            <div class="slider-container">
                                <input type="range" id="slider-link-distance" min="10" max="300" value="100" oninput="updateGraphForce('linkDistance', this.value)">
                            </div>
                            <span class="slider-value" id="value-link-distance">100</span>
                        </div>

                        <button type="button" class="reset-btn" onclick="resetGraphForces()">Reset to Defaults</button>
                    </div>
                </div>
            </div>
        </aside>

        <!-- 3D Canvas -->
        <main class="canvas-container">
            <div id="constellation-background"></div>
            <div id="node-tooltip"></div>
        </main>

        <!-- Activity Bar -->
        <footer class="activity-bar">
            <span class="activity-label">Activity</span>
            <!-- Smasher current file indicator -->
            <div class="smasher-current" id="smasher-current">
                <span class="smasher-current-label">ANALYZING:</span>
                <span class="smasher-current-file" id="smasher-current-file">--</span>
                <span class="smasher-current-e" id="smasher-current-e"></span>
            </div>
            <div class="activity-feed" id="activity-feed">
                <div class="activity-item" style="color: var(--text-muted);">Waiting for daemon...</div>
            </div>
        </footer>
    </div>

    <!-- Chat Toggle Button -->
    <button class="chat-toggle" id="chat-toggle" onclick="toggleChat()">
        <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
            <path d="M20 2H4c-1.1 0-2 .9-2 2v18l4-4h14c1.1 0 2-.9 2-2V4c0-1.1-.9-2-2-2zm0 14H5.2L4 17.2V4h16v12z"/>
        </svg>
    </button>

    <!-- Chat Panel -->
    <div class="chat-panel" id="chat-panel">
        <div class="chat-header">
            <span class="chat-title">Chat with Feral</span>
            <button class="chat-close" onclick="toggleChat()">&times;</button>
        </div>
        <div class="chat-messages" id="chat-messages"></div>
        <div class="chat-input-area">
            <div class="chat-input-row">
                <input type="text" class="chat-input" id="chat-input" placeholder="Ask something..." onkeypress="if(event.key==='Enter')sendMessage()">
                <button class="chat-send" onclick="sendMessage()">Send</button>
            </div>
        </div>
    </div>

    <script>
        // ===== STATE =====
        let ws = null;
        let daemonRunning = false;
        let behaviors = {};
        let chatOpen = false;
        let sidebarCollapsed = false;
        let threejsReady = false;
        let pendingThoughtId = null; // Track pending chat to prevent duplicates
        let showSimilarityLinks = true;
        let similarityThreshold = 0.7;
        let allLinks = []; // Store all links for filtering

        // Particle Smasher state
        let smasherActive = false;
        let smasherConfig = { delay_ms: 100, batch_size: 10, E_threshold: 0.3 };
        let staticCameraMode = true;  // Default ON for smasher visualization

        // Render throttling for smasher
        let smashQueue = [];
        let smashRafPending = false;
        const MAX_SMASH_BATCH = 5;  // Process max 5 smashes per frame

        // ===== SIDEBAR TOGGLE =====
        function toggleSidebar() {
            sidebarCollapsed = !sidebarCollapsed;
            document.getElementById('app').classList.toggle('sidebar-collapsed', sidebarCollapsed);
        }

        // ===== SECTION TOGGLE =====
        function toggleSection(name) {
            const section = document.getElementById(`section-${name}`);
            section.classList.toggle('collapsed');
        }

        // ===== CHAT TOGGLE =====
        function toggleChat() {
            chatOpen = !chatOpen;
            document.getElementById('chat-panel').classList.toggle('open', chatOpen);
        }

        // ===== API HELPERS =====
        async function api(endpoint, options = {}) {
            const res = await fetch(`/api${endpoint}`, {
                headers: { 'Content-Type': 'application/json' },
                ...options
            });
            return res.json();
        }

        // ===== WEBSOCKET =====
        function connectWebSocket() {
            const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
            ws = new WebSocket(`${protocol}//${window.location.host}/ws`);

            ws.onopen = () => {
                document.getElementById('ws-dot').classList.remove('offline');
                document.getElementById('ws-status-text').innerText = 'Connected';
            };

            ws.onclose = () => {
                document.getElementById('ws-dot').classList.add('offline');
                document.getElementById('ws-status-text').innerText = 'Disconnected';
                setTimeout(connectWebSocket, 3000);
            };

            ws.onmessage = (event) => {
                const msg = JSON.parse(event.data);
                handleWebSocketMessage(msg);
            };
        }

        function handleWebSocketMessage(msg) {
            if (msg.type === 'init') {
                updateMindState(msg.data.mind);
                updateDaemonStatus(msg.data.daemon);
            } else if (msg.type === 'mind_update') {
                updateMindState(msg.data);
            } else if (msg.type === 'activity') {
                addActivity(msg.data);
            } else if (msg.type === 'node_discovered') {
                spawnNode(msg.data);
                addToTrail(msg.data.node_id, msg.data.activity_type);
            } else if (msg.type === 'node_activated') {
                activateNode(msg.data.node_id, msg.data.activity_type);
                addToTrail(msg.data.node_id, msg.data.activity_type);
            } else if (msg.type === 'smash_hit') {
                // Particle Smasher: throttled processing to prevent render overload
                updateCurrentFile(msg.data);
                updateSmasherStats(msg.data.rate);
                queueSmashVisualization(msg.data);
            } else if (msg.type === 'hot_reload') {
                // HOT RELOAD: Refresh page when static files change
                console.log('[HOT RELOAD] File changed, reloading...');
                window.location.reload();
            }
            // NOTE: Removed 'thought' handler - API response handles chat messages
            // This fixes the duplicate message bug
        }

        // ===== MIND STATE =====
        function updateMindState(data) {
            if (data.Df !== undefined) {
                document.getElementById('mind-df').innerText = data.Df.toFixed(1);
                document.getElementById('df-progress').style.width = Math.min(100, data.Df / 2.56) + '%';
            }
            if (data.distance !== undefined) {
                document.getElementById('mind-distance').innerText = data.distance.toFixed(3);
            }
        }

        async function loadStatus() {
            try {
                const data = await api('/status');
                if (data.ok) {
                    document.getElementById('mind-df').innerText = data.mind.Df.toFixed(1);
                    document.getElementById('df-progress').style.width = Math.min(100, data.mind.Df / 2.56) + '%';
                    document.getElementById('mind-distance').innerText = data.mind.distance_from_start.toFixed(3);
                    document.getElementById('mind-interactions').innerText = data.interactions;
                }
            } catch (e) {
                console.error('Failed to load status:', e);
            }
        }

        async function loadEvolution() {
            try {
                const data = await api('/evolution');
                if (data.ok && data.Df_history) {
                    updateSparkline(data.Df_history);
                }
            } catch (e) {
                console.error('Failed to load evolution:', e);
            }
        }

        function updateSparkline(history) {
            const container = document.getElementById('df-sparkline');
            const last30 = history.slice(-30);
            if (last30.length === 0) return;

            const max = Math.max(...last30);
            const min = Math.min(...last30);
            const range = max - min || 1;

            container.innerHTML = '';
            last30.forEach(v => {
                const bar = document.createElement('div');
                bar.className = 'spark-bar';
                const height = ((v - min) / range) * 100;
                bar.style.height = Math.max(5, height) + '%';
                container.appendChild(bar);
            });
        }

        // ===== DAEMON CONTROL =====
        async function loadDaemonStatus() {
            try {
                const data = await api('/daemon/status');
                if (data.ok) {
                    updateDaemonStatus(data);
                }
            } catch (e) {
                console.error('Failed to load daemon status:', e);
            }
        }

        function updateDaemonStatus(data) {
            daemonRunning = data.running;
            behaviors = data.behaviors || {};

            document.getElementById('daemon-status-text').innerText = data.running ? 'Running' : 'Stopped';
            document.getElementById('daemon-led').className = data.running ? 'daemon-led on' : 'daemon-led';
            const btn = document.getElementById('daemon-toggle-btn');
            btn.innerText = data.running ? 'Stop' : 'Start';
            btn.className = data.running ? 'daemon-btn' : 'daemon-btn primary';

            updateBehaviorUI('paper_exploration', 'paper');
            updateBehaviorUI('memory_consolidation', 'consolidate');
            updateBehaviorUI('self_reflection', 'reflect');
            updateBehaviorUI('cassette_watch', 'cassette');

            // Sync E threshold slider with daemon's actual state
            if (data.E_threshold !== undefined) {
                const thresholdPercent = Math.round(data.E_threshold * 100);
                document.getElementById('slider-e-threshold').value = thresholdPercent;
                document.getElementById('value-e-threshold').innerText = data.E_threshold.toFixed(2);
                smasherConfig.E_threshold = data.E_threshold;
            }
        }

        function updateBehaviorUI(name, shortName) {
            const toggle = document.getElementById(`toggle-${shortName}`);
            const input = document.getElementById(`input-${shortName}`);

            if (behaviors[name]) {
                toggle.className = behaviors[name].enabled ? 'behavior-toggle on' : 'behavior-toggle';
                if (input) input.value = behaviors[name].interval;
            }
        }

        async function toggleDaemon() {
            if (daemonRunning) {
                await api('/daemon/stop', { method: 'POST' });
            } else {
                await api('/daemon/start', { method: 'POST' });
            }
            loadDaemonStatus();
        }

        async function toggleBehavior(name) {
            if (!behaviors[name]) return;
            const newEnabled = !behaviors[name].enabled;
            await api('/daemon/config', {
                method: 'POST',
                body: JSON.stringify({ behavior: name, enabled: newEnabled })
            });
            loadDaemonStatus();
        }

        async function updateInterval(name, seconds) {
            const interval = parseInt(seconds, 10);
            if (isNaN(interval) || interval < 5) return;
            await api('/daemon/config', {
                method: 'POST',
                body: JSON.stringify({ behavior: name, interval: interval })
            });
            loadDaemonStatus();
        }

        // ===== SIMILARITY CONTROLS =====
        function toggleSimilarityLinks() {
            showSimilarityLinks = !showSimilarityLinks;
            document.getElementById('toggle-similarity').className = showSimilarityLinks ? 'behavior-toggle on' : 'behavior-toggle';
            updateVisibleLinks();
            saveSettings();  // Persist immediately
        }

        function updateSimThreshold(value) {
            similarityThreshold = value / 100;
            document.getElementById('value-sim-threshold').innerText = similarityThreshold.toFixed(2);
            // Reload constellation with new threshold
            reloadConstellation();
        }

        async function reloadConstellation() {
            if (!Graph) return;
            try {
                const res = await fetch(`/api/constellation?include_similarity=true&similarity_threshold=${similarityThreshold}`);
                const data = await res.json();
                if (!data.ok) return;

                const nodes = data.nodes.map(n => ({
                    id: n.id,
                    label: n.label,
                    group: n.group,
                    path: n.path || '',
                    val: n.group === 'folder' ? 3 : 1
                }));

                allLinks = data.edges.map(e => ({
                    source: e.from,
                    target: e.to,
                    type: e.type || 'hierarchy',
                    weight: e.weight || 0.5
                }));

                nodes.forEach(n => nodeRegistry.byId.set(n.id, n));
                const visibleLinks = filterLinks(allLinks);
                Graph.graphData({ nodes, links: visibleLinks });
            } catch (e) {
                console.error('Failed to reload constellation:', e);
            }
        }

        function filterLinks(links) {
            if (showSimilarityLinks) {
                return links;
            }
            return links.filter(l => l.type !== 'similarity');
        }

        function updateVisibleLinks() {
            if (!Graph || allLinks.length === 0) return;
            const graphData = Graph.graphData();
            const visibleLinks = filterLinks(allLinks);
            Graph.graphData({ nodes: graphData.nodes, links: visibleLinks });
        }

        // ===== FOG CONTROL =====
        function updateFog(value) {
            if (!Graph) return;
            const density = (value / 100) * 0.01; // 0 to 0.01 range
            Graph.scene().fog.density = density;
            document.getElementById('value-fog').innerText = density.toFixed(4);
        }

        // ===== GRAPH FORCE CONTROLS =====
        function updateGraphForce(force, value) {
            if (!Graph || !window.graphForces) return;
            const numValue = parseFloat(value);

            switch (force) {
                case 'center':
                    const centerStrength = numValue / 100;
                    window.graphForces.centerStrength = centerStrength;
                    Graph.d3Force('center').strength(centerStrength);
                    document.getElementById('value-center').innerText = centerStrength.toFixed(2);
                    break;
                case 'repel':
                    const chargeStrength = -numValue;
                    window.graphForces.chargeStrength = chargeStrength;
                    Graph.d3Force('charge').strength(chargeStrength);
                    document.getElementById('value-repel').innerText = chargeStrength;
                    break;
                case 'linkStrength':
                    const linkStr = numValue / 100;
                    window.graphForces.linkStrength = linkStr;
                    Graph.d3Force('link').strength(linkStr);
                    document.getElementById('value-link-strength').innerText = linkStr.toFixed(2);
                    break;
                case 'linkDistance':
                    window.graphForces.linkDistance = numValue;
                    Graph.d3Force('link').distance(numValue);
                    document.getElementById('value-link-distance').innerText = numValue;
                    break;
            }
            Graph.d3ReheatSimulation();
        }

        function resetGraphForces() {
            if (!Graph) return;
            window.graphForces = {
                linkDistance: 100,
                linkStrength: 0.5,
                chargeStrength: -120,
                centerStrength: 0.05
            };
            Graph.d3Force('link').distance(100).strength(0.5);
            Graph.d3Force('charge').strength(-120);
            Graph.d3Force('center').strength(0.05);
            Graph.scene().fog.density = 0.003;
            Graph.d3ReheatSimulation();

            // Reset similarity settings
            showSimilarityLinks = true;
            similarityThreshold = 0.7;
            document.getElementById('toggle-similarity').className = 'behavior-toggle on';
            document.getElementById('slider-sim-threshold').value = 70;
            document.getElementById('value-sim-threshold').innerText = '0.70';

            document.getElementById('slider-fog').value = 30;
            document.getElementById('slider-center').value = 5;
            document.getElementById('slider-repel').value = 120;
            document.getElementById('slider-link-strength').value = 50;
            document.getElementById('slider-link-distance').value = 100;
            document.getElementById('value-fog').innerText = '0.003';
            document.getElementById('value-center').innerText = '0.05';
            document.getElementById('value-repel').innerText = '-120';
            document.getElementById('value-link-strength').innerText = '0.50';
            document.getElementById('value-link-distance').innerText = '100';

            reloadConstellation();
        }

        // ===== PARTICLE SMASHER CONTROLS =====
        async function toggleSmasher() {
            if (smasherActive) {
                await stopSmasher();
            } else {
                await startSmasher();
            }
        }

        async function startSmasher() {
            try {
                clearCurrentFile();  // Reset current file display
                const res = await api('/smasher/start', {
                    method: 'POST',
                    body: JSON.stringify({
                        delay_ms: smasherConfig.delay_ms,
                        batch_size: smasherConfig.batch_size,
                        batch_pause_ms: 200,
                        max_chunks: 0
                    })
                });
                if (res.ok) {
                    smasherActive = true;
                    updateSmasherUI();
                }
            } catch (e) {
                console.error('Failed to start smasher:', e);
            }
        }

        async function stopSmasher() {
            try {
                const res = await api('/smasher/stop', { method: 'POST' });
                smasherActive = false;
                updateSmasherUI();
            } catch (e) {
                console.error('Failed to stop smasher:', e);
            }
        }

        function updateSmasherUI() {
            const led = document.getElementById('smasher-led');
            const text = document.getElementById('smasher-status-text');
            const btn = document.getElementById('smasher-toggle-btn');
            const stats = document.getElementById('smasher-stats');
            const currentFile = document.getElementById('smasher-current');

            if (smasherActive) {
                led.className = 'daemon-led on';
                text.innerText = 'SMASHING';
                btn.innerText = 'STOP';
                btn.className = 'daemon-btn';
                stats.style.display = 'block';
                currentFile.classList.add('active');
            } else {
                led.className = 'daemon-led';
                text.innerText = 'Idle';
                btn.innerText = 'SMASH';
                btn.className = 'daemon-btn primary';
                currentFile.classList.remove('active');
            }
        }

        function updateSmasherStats(rate) {
            document.getElementById('smasher-rate').innerText = rate.toFixed(1);
        }

        // Update the single-line current file indicator
        function updateCurrentFile(data) {
            const container = document.getElementById('smasher-current');
            const fileEl = document.getElementById('smasher-current-file');
            const eEl = document.getElementById('smasher-current-e');

            container.classList.add('active');

            const nodeId = data.node_id || '';
            const parts = nodeId.split(':');
            const fileName = parts.length > 2 ? `${parts[1]}/${parts[2]}` : nodeId;

            fileEl.innerText = fileName;
            fileEl.title = nodeId;

            const E = data.E || 0;
            const gateOpen = data.gate_open;
            eEl.innerText = `E=${E.toFixed(2)} ${gateOpen ? 'ABSORBED' : 'REJECTED'}`;
            eEl.className = `smasher-current-e ${gateOpen ? 'open' : 'closed'}`;
        }

        function clearCurrentFile() {
            const container = document.getElementById('smasher-current');
            container.classList.remove('active');
            document.getElementById('smasher-current-file').innerText = '--';
            document.getElementById('smasher-current-e').innerText = '';
        }

        // Queue smash visualization with throttling
        function queueSmashVisualization(data) {
            smashQueue.push(data);
            if (!smashRafPending) {
                smashRafPending = true;
                requestAnimationFrame(processSmashQueue);
            }
        }

        // Process queued smash visualizations (batched - SINGLE graph update)
        function processSmashQueue() {
            smashRafPending = false;
            const batch = smashQueue.splice(0, MAX_SMASH_BATCH);
            if (batch.length === 0 || !Graph) return;

            // Get graph data ONCE for entire batch
            const graphData = Graph.graphData();
            let graphUpdated = false;
            const nodesToFlash = [];

            for (const data of batch) {
                const result = processSmashItem(data, graphData);
                if (result.updated) graphUpdated = true;
                if (result.node) nodesToFlash.push({ nodeId: data.node_id, gateOpen: data.gate_open, E: data.E });
            }

            // Update graph ONCE for entire batch
            if (graphUpdated) {
                Graph.graphData(graphData);
            }

            // Flash nodes after graph update
            for (const item of nodesToFlash) {
                flashNode(item.nodeId, item.gateOpen, item.E);
            }

            // If more in queue, schedule another frame
            if (smashQueue.length > 0) {
                smashRafPending = true;
                requestAnimationFrame(processSmashQueue);
            }
        }

        // Process single smash item (returns {updated, node})
        // Uses SEMANTIC SIMILARITY for positioning - connects to most similar existing node
        function processSmashItem(data, graphData) {
            const nodeId = data.node_id;
            const similarTo = data.similar_to;  // SEMANTIC anchor (most similar existing node)
            const similarE = data.similar_E || 0;
            let updated = false;

            // Try to find existing node in registry
            let node = nodeRegistry.byId.get(nodeId);

            // If node doesn't exist, create it dynamically
            if (!node && data.is_new_node) {
                // Position near SEMANTICALLY SIMILAR node (not sequential!)
                let pos = { x: 0, y: 0, z: 0 };
                let foundAnchor = false;

                if (similarTo) {
                    const anchorNode = nodeRegistry.byId.get(similarTo);
                    if (anchorNode && anchorNode.x !== undefined) {
                        // Position near similar node - offset scaled by similarity
                        // High similarity = closer, low similarity = further
                        const offset = 15 + (1 - similarE) * 25;  // 15-40 units based on similarity
                        pos = {
                            x: anchorNode.x + (Math.random() - 0.5) * offset,
                            y: anchorNode.y + (Math.random() - 0.5) * offset,
                            z: anchorNode.z + (Math.random() - 0.5) * offset
                        };
                        foundAnchor = true;
                    }
                }

                // No anchor found - place near center, force sim will position
                if (!foundAnchor) {
                    pos = {
                        x: (Math.random() - 0.5) * 30,
                        y: (Math.random() - 0.5) * 30,
                        z: (Math.random() - 0.5) * 30
                    };
                }

                const parts = nodeId.split(':');
                const label = parts.length > 2 ? parts[2] : 'chunk';

                node = {
                    id: nodeId,
                    label: label,
                    group: 'page',
                    val: 1,
                    x: pos.x,
                    y: pos.y,
                    z: pos.z
                };

                nodeRegistry.byId.set(nodeId, node);
                graphData.nodes.push(node);
                updated = true;

                // Initialize pulse state
                nodePulseState.set(nodeId, {
                    intensity: 1.5,
                    phase: 0,
                    frequency: 2.0,
                    lastActivity: Date.now()
                });
            }

            // Create SIMILARITY edge to anchor node (semantic connection!)
            if (similarTo && similarE > 0.3) {  // Only connect if reasonably similar
                const hasAnchor = nodeRegistry.byId.has(similarTo);
                const hasTarget = nodeRegistry.byId.has(nodeId);

                if (hasAnchor && hasTarget) {
                    // Check if edge already exists
                    const edgeExists = graphData.links.some(l =>
                        ((l.source.id || l.source) === similarTo) &&
                        ((l.target.id || l.target) === nodeId) &&
                        l.type === 'similarity'
                    );
                    if (!edgeExists) {
                        graphData.links.push({
                            source: similarTo,
                            target: nodeId,
                            type: 'similarity',
                            weight: similarE  // Store similarity score for edge width
                        });
                        updated = true;
                    }
                }
            }

            // Add to exploration trail
            addToTrail(nodeId, 'smash');

            return { updated, node };
        }

        async function updateSmasherSpeed(value) {
            smasherConfig.delay_ms = parseInt(value);
            document.getElementById('value-smasher-speed').innerText = value + 'ms';
            // LIVE update - no restart needed
            await sendSmasherConfig({ delay_ms: smasherConfig.delay_ms });
        }

        async function updateSmasherBatch(value) {
            smasherConfig.batch_size = parseInt(value);
            document.getElementById('value-smasher-batch').innerText = value;
            // LIVE update - no restart needed
            await sendSmasherConfig({ batch_size: smasherConfig.batch_size });
        }

        async function updateEThreshold(value) {
            const threshold = parseInt(value) / 100;
            smasherConfig.E_threshold = threshold;
            document.getElementById('value-e-threshold').innerText = threshold.toFixed(2);
            // LIVE update - no restart needed
            await sendSmasherConfig({ E_threshold: threshold });
        }

        // Send config update to server (LIVE, no restart needed)
        async function sendSmasherConfig(updates) {
            try {
                await api('/smasher/config', {
                    method: 'POST',
                    body: JSON.stringify(updates)
                });
            } catch (e) {
                console.error('Failed to update smasher config:', e);
            }
        }

        function toggleStaticCamera() {
            staticCameraMode = !staticCameraMode;
            document.getElementById('toggle-static-camera').className =
                staticCameraMode ? 'behavior-toggle on' : 'behavior-toggle';
            saveSettings();  // Persist immediately
        }

        async function loadSmasherStatus() {
            try {
                const res = await api('/smasher/status');
                if (res.ok) {
                    smasherActive = res.active;
                    if (res.stats) {
                        document.getElementById('smasher-processed').innerText = res.stats.chunks_processed;
                        document.getElementById('smasher-absorbed').innerText = res.stats.chunks_absorbed;
                        document.getElementById('smasher-rejected').innerText = res.stats.chunks_rejected;
                        document.getElementById('smasher-rate').innerText = res.stats.chunks_per_second.toFixed(1);
                    }
                    updateSmasherUI();
                }
            } catch (e) {
                // Ignore
            }
        }

        // Flash a node DRAMATICALLY (for particle smasher) - OPTIMIZED
        function flashNode(nodeId, gateOpen, E) {
            const node = nodeRegistry.byId.get(nodeId);
            if (!node) return;

            // Color based on gate status
            const flashColor = gateOpen ? 0x00ff41 : 0xff4444;  // Green=absorbed, Red=rejected

            if (node.__mainSphere) {
                // Scale up and change color (BasicMaterial - no emissive)
                node.__mainSphere.scale.setScalar(3.0);
                node.__mainSphere.material.color.setHex(flashColor);
                node.__mainSphere.material.opacity = 1.0;

                // Single timeout to reset (PERFORMANCE: fewer timers)
                setTimeout(() => {
                    if (node.__mainSphere) {
                        node.__mainSphere.scale.setScalar(1.0);
                        node.__mainSphere.material.color.setHex(node.group === 'folder' ? 0x00ff41 : 0x008f11);
                        node.__mainSphere.material.opacity = 0.9;
                    }
                }, 300);
            }

            if (node.__glowSphere) {
                node.__glowSphere.scale.setScalar(3.0);
                node.__glowSphere.material.color.setHex(flashColor);
                node.__glowSphere.material.opacity = 0.6;

                setTimeout(() => {
                    if (node.__glowSphere) {
                        node.__glowSphere.scale.setScalar(1.3);
                        node.__glowSphere.material.color.setHex(0x00ff41);
                        node.__glowSphere.material.opacity = 0.15;
                    }
                }, 300);
            }

            // NO camera follow in static mode
            if (!staticCameraMode) {
                focusCameraOnNode(node, 500);
            }
        }

        // ===== CHAT =====
        async function sendMessage() {
            const input = document.getElementById('chat-input');
            const query = input.value.trim();
            if (!query) return;

            input.value = '';
            addChatMessage('user', query);

            try {
                const data = await api('/think', {
                    method: 'POST',
                    body: JSON.stringify({ query })
                });
                addChatMessage('feral', data.response, data.E_resonance, data.gate_open);
                loadStatus();
                loadEvolution();
            } catch (e) {
                addChatMessage('feral', '[ERROR] Failed to get response', 0, false);
            }
        }

        function addChatMessage(role, text, E = null, gateOpen = null) {
            const container = document.getElementById('chat-messages');
            const msg = document.createElement('div');
            msg.className = `chat-msg ${role}`;

            let meta = `<span class="chat-sender">${role === 'user' ? 'You' : 'Feral'}</span>`;
            if (E !== null) {
                const badgeClass = gateOpen ? 'open' : 'closed';
                meta += `<span class="chat-e-badge ${badgeClass}">E=${E.toFixed(2)} ${gateOpen ? 'OPEN' : 'CLOSED'}</span>`;
            }

            msg.innerHTML = `
                <div class="chat-meta">${meta}</div>
                <div class="chat-bubble">${text}</div>
            `;
            container.appendChild(msg);
            container.scrollTop = container.scrollHeight;
        }

        // ===== ACTIVITY =====
        function addActivity(activity) {
            const feed = document.getElementById('activity-feed');

            // Remove placeholder
            if (feed.children.length === 1 && feed.children[0].style.color) {
                feed.innerHTML = '';
            }

            const item = document.createElement('div');
            item.className = 'activity-item';

            const time = new Date(activity.timestamp).toLocaleTimeString('en-US', {
                hour: '2-digit',
                minute: '2-digit',
                second: '2-digit',
                hour12: false
            });

            item.innerHTML = `
                <span class="activity-time">${time}</span>
                <span class="activity-badge ${activity.action}">${activity.action}</span>
                <span class="activity-text">${activity.summary}</span>
            `;

            feed.insertBefore(item, feed.firstChild);

            // Limit items
            while (feed.children.length > 20) {
                feed.removeChild(feed.lastChild);
            }
        }

        // ===== 3D CONSTELLATION =====
        let Graph = null;
        let nodeRegistry = { byId: new Map() };
        let nodePulseState = new Map();
        let explorationTrail = [];
        let trailLine = null;
        const MAX_TRAIL_LENGTH = 50;

        const ACTIVITY_COLORS = {
            paper: { main: 0x00ff41, glow: '#00ff41' },
            consolidate: { main: 0x00ff41, glow: '#00ff41' },
            reflect: { main: 0x00ff41, glow: '#00ff41' },
            cassette: { main: 0x00ff41, glow: '#00ff41' },
            daemon: { main: 0x00ff41, glow: '#00ff41' },
            default: { main: 0x00ff41, glow: '#00ff41' }
        };

        function waitForThreeJS() {
            return new Promise((resolve) => {
                function check() {
                    if (typeof THREE !== 'undefined' && typeof ForceGraph3D !== 'undefined') {
                        resolve();
                    } else {
                        setTimeout(check, 100);
                    }
                }
                check();
            });
        }

        async function initConstellation() {
            await waitForThreeJS();

            const container = document.getElementById('constellation-background');
            const tooltip = document.getElementById('node-tooltip');

            try {
                console.log('[CONSTELLATION] Fetching data...');
                const res = await fetch('/api/constellation?include_similarity=true&similarity_threshold=' + similarityThreshold);
                const data = await res.json();
                console.log('[CONSTELLATION] Response:', data.ok, 'nodes:', data.nodes?.length, 'edges:', data.edges?.length);

                if (!data.ok || !data.nodes || data.nodes.length === 0) {
                    console.log('[CONSTELLATION] No data available:', data.error || 'empty');
                    return;
                }

                const nodes = data.nodes.map(n => ({
                    id: n.id,
                    label: n.label,
                    group: n.group,
                    path: n.path || '',
                    val: n.group === 'folder' ? 3 : 1
                }));

                allLinks = data.edges.map(e => ({
                    source: e.from,
                    target: e.to,
                    type: e.type || 'hierarchy',  // 'hierarchy' or 'similarity'
                    weight: e.weight || 0.5
                }));

                const links = filterLinks(allLinks);
                console.log('[CONSTELLATION] Nodes:', nodes.length, 'Links:', links.length);

                nodes.forEach(n => nodeRegistry.byId.set(n.id, n));

                nodes.forEach(n => {
                    nodePulseState.set(n.id, {
                        intensity: 0.4,  // Higher base intensity for visible pulse
                        phase: Math.random() * Math.PI * 2,
                        frequency: 0.5 + Math.random() * 0.5,  // Faster pulse
                        lastActivity: Date.now()  // Start active
                    });
                });

                console.log('[CONSTELLATION] Creating graph with', nodes.length, 'nodes and', links.length, 'links');

                Graph = ForceGraph3D({ controlType: 'orbit' })(container)
                    .graphData({ nodes, links })
                    .backgroundColor('#000000')
                    .showNavInfo(false)
                    .nodeLabel(node => `${node.label}\n${node.path || node.id}`)
                    .nodeColor(node => node.group === 'folder' ? '#00ff41' : '#008f11')
                    .nodeOpacity(0.9)
                    .nodeResolution(8)  // PERFORMANCE: Lower poly count
                    .nodeVal(node => node.val)
                    .linkColor(link => {
                        // Smash trail edges in bright orange
                        if (link.type === 'smash_trail') {
                            return 'rgba(255, 102, 0, 0.9)';
                        }
                        // Similarity edges in lighter cyan with more transparency
                        if (link.type === 'similarity') {
                            const alpha = 0.15 + (link.weight || 0.5) * 0.25;  // Reduced opacity
                            return `rgba(100, 255, 255, ${alpha})`;  // Lighter cyan
                        }
                        return 'rgba(0, 143, 17, 0.2)';
                    })
                    .linkWidth(link => {
                        if (link.type === 'smash_trail') return 2;
                        if (link.type === 'similarity') return 1;
                        return 0.3;
                    })
                    .linkOpacity(link => {
                        if (link.type === 'smash_trail') return 1.0;
                        if (link.type === 'similarity') return 0.3;  // More transparent
                        return 0.2;
                    })
                    .d3AlphaDecay(0.02)  // PERFORMANCE: Faster settling
                    .d3VelocityDecay(0.5)  // PERFORMANCE: Less momentum
                    .warmupTicks(50)   // PERFORMANCE: Less initial compute
                    .cooldownTicks(100)  // PERFORMANCE: Faster cooldown
                    .enableNodeDrag(false)  // PERFORMANCE: Disable dragging
                    .onNodeHover(node => {
                        if (node) {
                            tooltip.innerHTML = `<strong>${node.label}</strong><br><span style="color: var(--text-muted)">${node.path || node.id}</span>`;
                            tooltip.style.display = 'block';
                        } else {
                            tooltip.style.display = 'none';
                        }
                    })
                    .onNodeClick(node => {
                        if (node) focusCameraOnNode(node, 1500);
                    });

                window.graphForces = {
                    linkDistance: 100,
                    linkStrength: 0.5,
                    chargeStrength: -120,
                    centerStrength: 0.05
                };

                Graph.d3Force('link').distance(100).strength(0.5);
                Graph.d3Force('charge').strength(-120).distanceMax(300);
                Graph.d3Force('center').strength(0.05);

                Graph.nodeThreeObject(node => {
                    const group = new THREE.Group();

                    // PERFORMANCE: Use 8 segments instead of 16 (way fewer triangles)
                    const size = node.group === 'folder' ? 4 : 2;
                    const geometry = new THREE.SphereGeometry(size, 8, 8);
                    const material = new THREE.MeshBasicMaterial({  // PERFORMANCE: BasicMaterial instead of Phong
                        color: node.group === 'folder' ? 0x00ff41 : 0x008f11,
                        transparent: true,
                        opacity: 0.9
                    });
                    const sphere = new THREE.Mesh(geometry, material);
                    group.add(sphere);

                    // PERFORMANCE: Simpler glow with fewer segments
                    const glowGeometry = new THREE.SphereGeometry(size * 1.3, 6, 6);
                    const glowMaterial = new THREE.MeshBasicMaterial({
                        color: 0x00ff41,
                        transparent: true,
                        opacity: 0.15
                    });
                    const glow = new THREE.Mesh(glowGeometry, glowMaterial);
                    group.add(glow);

                    node.__mainSphere = sphere;
                    node.__glowSphere = glow;

                    return group;
                });

                const scene = Graph.scene();
                scene.add(new THREE.AmbientLight(0x00ff41, 0.3));
                const pointLight = new THREE.PointLight(0x00ff41, 1, 500);
                pointLight.position.set(0, 100, 100);
                scene.add(pointLight);
                scene.fog = new THREE.FogExp2(0x000000, 0.003);

                Graph.cameraPosition({ x: 0, y: 0, z: 400 }, { x: 0, y: 0, z: 0 }, 0);

                document.addEventListener('mousemove', (e) => {
                    if (tooltip.style.display === 'block') {
                        tooltip.style.left = (e.clientX + 15) + 'px';
                        tooltip.style.top = (e.clientY + 15) + 'px';
                    }
                });

                startPulseAnimation();
                console.log(`Constellation initialized with ${nodes.length} nodes`);

            } catch (e) {
                console.error('Constellation init error:', e);
            }
        }

        // PERFORMANCE: Disabled continuous animation - too expensive
        // Pulse effects now only happen on flash events
        function startPulseAnimation() {
            // Intentionally empty - animations are handled per-flash now
            console.log('[PERFORMANCE] Continuous pulse animation disabled');
        }

        function focusCameraOnNode(node, duration = 1500) {
            if (!Graph || !node) return;
            const distance = 150;
            const distRatio = 1 + distance / Math.max(10, Math.hypot(node.x || 0, node.y || 0, node.z || 0));
            Graph.cameraPosition(
                { x: (node.x || 0) * distRatio, y: (node.y || 0) * distRatio, z: (node.z || 0) * distRatio },
                { x: node.x || 0, y: node.y || 0, z: node.z || 0 },
                duration
            );
        }

        function addToTrail(nodeId, activityType) {
            explorationTrail.push({ nodeId, timestamp: Date.now(), type: activityType });
            while (explorationTrail.length > MAX_TRAIL_LENGTH) explorationTrail.shift();
            updateTrailVisualization();
        }

        function updateTrailVisualization() {
            if (!Graph) return;
            const scene = Graph.scene();

            if (trailLine) {
                scene.remove(trailLine);
                trailLine.geometry.dispose();
                trailLine.material.dispose();
                trailLine = null;
            }

            if (explorationTrail.length < 2) return;

            const points = [];
            const colors = [];

            explorationTrail.forEach((entry) => {
                const node = nodeRegistry.byId.get(entry.nodeId);
                if (!node || node.x === undefined) return;

                points.push(new THREE.Vector3(node.x, node.y, node.z));
                const age = (Date.now() - entry.timestamp) / 30000;
                const alpha = Math.max(0.1, 1 - age);
                const colorInfo = ACTIVITY_COLORS[entry.type] || ACTIVITY_COLORS.default;
                const color = new THREE.Color(colorInfo.main);
                colors.push(color.r * alpha, color.g * alpha, color.b * alpha);
            });

            if (points.length < 2) return;

            const geometry = new THREE.BufferGeometry().setFromPoints(points);
            geometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));
            const material = new THREE.LineBasicMaterial({ vertexColors: true, transparent: true, opacity: 0.7 });
            trailLine = new THREE.Line(geometry, material);
            scene.add(trailLine);
        }

        function spawnNode(nodeData) {
            if (!Graph) return;
            const graphData = Graph.graphData();
            if (nodeRegistry.byId.has(nodeData.node_id)) return;

            let parentPos = { x: 0, y: 0, z: 0 };
            if (nodeData.source_id) {
                const parent = nodeRegistry.byId.get(nodeData.source_id);
                if (parent && parent.x !== undefined) {
                    parentPos = { x: parent.x, y: parent.y, z: parent.z };
                }
            }

            const newNode = {
                id: nodeData.node_id,
                label: nodeData.label || 'new chunk',
                group: 'page',
                path: nodeData.paper || '',
                val: 1,
                x: parentPos.x + (Math.random() - 0.5) * 50,
                y: parentPos.y + (Math.random() - 0.5) * 50,
                z: parentPos.z + (Math.random() - 0.5) * 50
            };

            nodeRegistry.byId.set(newNode.id, newNode);
            graphData.nodes.push(newNode);

            if (nodeData.source_id && nodeRegistry.byId.has(nodeData.source_id)) {
                graphData.links.push({ source: nodeData.source_id, target: nodeData.node_id });
            }

            Graph.graphData(graphData);
            nodePulseState.set(newNode.id, { intensity: 1.0, phase: 0, frequency: 1.0, lastActivity: Date.now() });

            // Only follow camera if not in static mode
            if (!staticCameraMode) {
                setTimeout(() => {
                    const node = nodeRegistry.byId.get(nodeData.node_id);
                    if (node) focusCameraOnNode(node, 1500);
                }, 300);
            }
        }

        function activateNode(nodeId, activityType) {
            const node = nodeRegistry.byId.get(nodeId);
            if (!node) return;

            const state = nodePulseState.get(nodeId);
            if (state) {
                state.intensity = 1.0;
                state.lastActivity = Date.now();
            }

            const colorInfo = ACTIVITY_COLORS[activityType] || ACTIVITY_COLORS.default;
            if (node.__mainSphere) {
                node.__mainSphere.material.color.setHex(colorInfo.main);
                node.__mainSphere.material.emissive.setHex(colorInfo.main);
                node.__mainSphere.material.emissiveIntensity = 0.8;

                setTimeout(() => {
                    if (node.__mainSphere) {
                        node.__mainSphere.material.color.setHex(node.group === 'folder' ? 0x00ff41 : 0x008f11);
                        node.__mainSphere.material.emissive.setHex(node.group === 'folder' ? 0x003300 : 0x001a00);
                    }
                }, 3000);
            }

            if (node.__glowSphere) {
                node.__glowSphere.material.color.setHex(colorInfo.main);
                node.__glowSphere.material.opacity = 0.4;
            }

            // Only follow camera if not in static mode
            if (!staticCameraMode) {
                focusCameraOnNode(node, 1000);
            }
        }

        // ===== SETTINGS PERSISTENCE =====
        function saveSettings() {
            const settings = {
                // Smasher config
                smasher_delay_ms: smasherConfig.delay_ms,
                smasher_batch_size: smasherConfig.batch_size,
                smasher_E_threshold: smasherConfig.E_threshold,

                // Graph settings
                similarity_threshold: similarityThreshold,
                show_similarity_links: showSimilarityLinks,
                static_camera: staticCameraMode,

                // Force params (if Graph exists)
                fog_density: Graph ? parseFloat(document.getElementById('value-fog').innerText) : 0.003,
                center_strength: Graph ? parseFloat(document.getElementById('value-center').innerText) : 0.05,
                repel_strength: Graph ? parseFloat(document.getElementById('value-repel').innerText) : -120,
                link_strength: Graph ? parseFloat(document.getElementById('value-link-strength').innerText) : 0.5,
                link_distance: Graph ? parseFloat(document.getElementById('value-link-distance').innerText) : 100
            };

            localStorage.setItem('feral_settings', JSON.stringify(settings));
        }

        function loadSettings() {
            const saved = localStorage.getItem('feral_settings');
            if (!saved) return;

            try {
                const settings = JSON.parse(saved);

                // Restore smasher config
                if (settings.smasher_delay_ms !== undefined) {
                    smasherConfig.delay_ms = settings.smasher_delay_ms;
                    document.getElementById('slider-smasher-speed').value = settings.smasher_delay_ms;
                    document.getElementById('value-smasher-speed').innerText = settings.smasher_delay_ms + 'ms';
                }
                if (settings.smasher_batch_size !== undefined) {
                    smasherConfig.batch_size = settings.smasher_batch_size;
                    document.getElementById('slider-smasher-batch').value = settings.smasher_batch_size;
                    document.getElementById('value-smasher-batch').innerText = settings.smasher_batch_size;
                }
                if (settings.smasher_E_threshold !== undefined) {
                    smasherConfig.E_threshold = settings.smasher_E_threshold;
                    const thresholdPercent = Math.round(settings.smasher_E_threshold * 100);
                    document.getElementById('slider-e-threshold').value = thresholdPercent;
                    document.getElementById('value-e-threshold').innerText = settings.smasher_E_threshold.toFixed(2);
                }

                // Restore graph settings
                if (settings.similarity_threshold !== undefined) {
                    similarityThreshold = settings.similarity_threshold;
                    const simPercent = Math.round(settings.similarity_threshold * 100);
                    document.getElementById('slider-sim-threshold').value = simPercent;
                    document.getElementById('value-sim-threshold').innerText = settings.similarity_threshold.toFixed(2);
                }
                if (settings.show_similarity_links !== undefined) {
                    showSimilarityLinks = settings.show_similarity_links;
                    document.getElementById('toggle-similarity').className =
                        showSimilarityLinks ? 'behavior-toggle on' : 'behavior-toggle';
                }
                if (settings.static_camera !== undefined) {
                    staticCameraMode = settings.static_camera;
                    document.getElementById('toggle-static-camera').className =
                        staticCameraMode ? 'behavior-toggle on' : 'behavior-toggle';
                }

                // Restore force params
                if (settings.fog_density !== undefined) {
                    document.getElementById('slider-fog').value = Math.round(settings.fog_density * 10000);
                    document.getElementById('value-fog').innerText = settings.fog_density.toFixed(4);
                }
                if (settings.center_strength !== undefined) {
                    document.getElementById('slider-center').value = Math.round(settings.center_strength * 100);
                    document.getElementById('value-center').innerText = settings.center_strength.toFixed(2);
                }
                if (settings.repel_strength !== undefined) {
                    document.getElementById('slider-repel').value = settings.repel_strength;
                    document.getElementById('value-repel').innerText = settings.repel_strength;
                }
                if (settings.link_strength !== undefined) {
                    document.getElementById('slider-link-strength').value = Math.round(settings.link_strength * 100);
                    document.getElementById('value-link-strength').innerText = settings.link_strength.toFixed(2);
                }
                if (settings.link_distance !== undefined) {
                    document.getElementById('slider-link-distance').value = settings.link_distance;
                    document.getElementById('value-link-distance').innerText = settings.link_distance;
                }

                console.log('[SETTINGS] Restored from localStorage');
            } catch (e) {
                console.error('[SETTINGS] Failed to load:', e);
            }
        }

        // ===== INIT =====
        async function init() {
            loadSettings();  // Load saved settings first
            await initConstellation();
            await loadStatus();
            await loadEvolution();
            await loadDaemonStatus();
            await loadSmasherStatus();
            connectWebSocket();
            document.getElementById('loading').classList.add('hidden');

            setInterval(loadStatus, 10000);
            setInterval(loadEvolution, 30000);
            setInterval(loadDaemonStatus, 5000);
            setInterval(loadSmasherStatus, 1000);  // Fast polling for smasher stats
            setInterval(saveSettings, 5000);  // Auto-save settings every 5 seconds
        }

        window.onload = init;
    </script>
</body>

</html>
