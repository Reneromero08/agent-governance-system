<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>FERAL DASHBOARD // Autonomous Resident</title>
    <!-- Three.js + 3D Force Graph for dynamic constellation -->
    <script src="https://unpkg.com/three@0.160.0/build/three.min.js"></script>
    <script src="https://unpkg.com/d3-force-3d@3.0.5/dist/d3-force-3d.min.js"></script>
    <script src="https://unpkg.com/3d-force-graph@1.73.0/dist/3d-force-graph.min.js"></script>
    <style>
        :root {
            --bg: #000000;
            --surface: rgba(0, 20, 0, 0.85);
            --accent-cyan: #00ff41;
            --accent-dim: #008f11;
            --text: #00ff41;
            --border: #008f11;
            --glow: 0 0 10px rgba(0, 255, 65, 0.5);
            --danger: #ff4444;
        }

        body, html {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            background: #000000;
            color: var(--text);
            font-family: 'Lucida Console', 'Courier New', monospace;
            overflow: hidden;
        }

        /* Full-screen Constellation Background */
        #constellation-background {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            z-index: 1;
            background: #000000;
            cursor: grab;
        }

        #constellation-background:active {
            cursor: grabbing;
        }

        #constellation-background canvas {
            width: 100% !important;
            height: 100% !important;
        }

        /* Scanline Overlay */
        body::after {
            content: " ";
            display: block;
            position: fixed;
            top: 0;
            left: 0;
            bottom: 0;
            right: 0;
            background: linear-gradient(rgba(18, 16, 16, 0) 50%, rgba(0, 0, 0, 0.15) 50%);
            z-index: 1000;
            background-size: 100% 4px;
            pointer-events: none;
            opacity: 0.15;
        }

        #desktop {
            position: relative;
            width: 100vw;
            height: 100vh;
            padding: 20px;
            box-sizing: border-box;
            z-index: 10;
            pointer-events: none;
        }

        /* Window Styling */
        .window {
            position: absolute;
            background: var(--surface);
            -webkit-backdrop-filter: blur(12px);
            backdrop-filter: blur(12px);
            border: 1px solid var(--border);
            border-radius: 8px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5), inset 0 0 10px rgba(255, 255, 255, 0.02);
            display: flex;
            flex-direction: column;
            min-width: 300px;
            min-height: 150px;
            z-index: 100;
            pointer-events: auto;
        }

        .window-header {
            padding: 10px 15px;
            background: rgba(255, 255, 255, 0.05);
            border-bottom: 1px solid var(--border);
            cursor: move;
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-top-left-radius: 8px;
            border-top-right-radius: 8px;
        }

        .window-title {
            font-size: 12px;
            font-weight: 700;
            text-transform: uppercase;
            letter-spacing: 2px;
            color: var(--accent-cyan);
            text-shadow: var(--glow);
        }

        .window-content {
            flex: 1;
            padding: 15px;
            overflow-y: auto;
            font-size: 13px;
            line-height: 1.6;
        }

        /* Status Bar */
        .status-bar {
            position: fixed;
            bottom: 0;
            left: 0;
            width: 100%;
            height: 40px;
            background: rgba(0, 0, 0, 0.95);
            border-top: 1px solid var(--border);
            display: flex;
            align-items: center;
            padding: 0 20px;
            box-sizing: border-box;
            font-size: 12px;
            z-index: 1001;
        }

        .status-item {
            margin-right: 25px;
            display: flex;
            align-items: center;
            color: rgba(255, 255, 255, 0.5);
        }

        .status-item b {
            color: var(--accent-cyan);
            margin-left: 5px;
        }

        .led {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: var(--accent-cyan);
            margin-right: 8px;
            box-shadow: 0 0 5px var(--accent-cyan);
            animation: pulse 2s infinite;
        }

        .led.off {
            background: #444;
            box-shadow: none;
            animation: none;
        }

        @keyframes pulse {
            0% { opacity: 1; }
            50% { opacity: 0.3; }
            100% { opacity: 1; }
        }

        /* Mind State Panel */
        #mind-state {
            top: 30px;
            left: 30px;
            width: 350px;
            height: 280px;
        }

        .stat-row {
            display: flex;
            justify-content: space-between;
            padding: 8px 0;
            border-bottom: 1px solid rgba(0, 255, 65, 0.1);
        }

        .stat-label {
            opacity: 0.7;
        }

        .stat-value {
            font-weight: bold;
            color: var(--accent-cyan);
        }

        .progress-bar {
            width: 100%;
            height: 8px;
            background: rgba(0, 255, 65, 0.1);
            border-radius: 4px;
            margin-top: 5px;
            overflow: hidden;
        }

        .progress-fill {
            height: 100%;
            background: var(--accent-cyan);
            transition: width 0.3s ease;
        }

        .sparkline {
            height: 40px;
            margin-top: 10px;
            display: flex;
            align-items: flex-end;
            gap: 2px;
        }

        .spark-bar {
            flex: 1;
            background: var(--accent-cyan);
            min-height: 2px;
            opacity: 0.7;
            transition: height 0.3s ease;
        }

        /* Daemon Control Panel */
        #daemon-control {
            top: 30px;
            left: 400px;
            width: 380px;
            height: 280px;
        }

        .daemon-btn {
            padding: 8px 16px;
            background: var(--accent-dim);
            border: 1px solid var(--accent-cyan);
            color: var(--accent-cyan);
            cursor: pointer;
            font-family: inherit;
            font-size: 12px;
            margin-right: 10px;
            transition: all 0.2s;
        }

        .daemon-btn:hover {
            background: var(--accent-cyan);
            color: #000;
        }

        .daemon-btn.active {
            background: var(--accent-cyan);
            color: #000;
        }

        .behavior-row {
            display: flex;
            align-items: center;
            padding: 8px 0;
            border-bottom: 1px solid rgba(0, 255, 65, 0.1);
        }

        .behavior-toggle {
            width: 16px;
            height: 16px;
            border: 1px solid var(--accent-cyan);
            background: transparent;
            cursor: pointer;
            margin-right: 10px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .behavior-toggle.on {
            background: var(--accent-cyan);
            color: #000;
        }

        .behavior-toggle.on::after {
            content: "âœ“";
            font-size: 10px;
        }

        .behavior-name {
            flex: 1;
        }

        .behavior-interval {
            font-size: 11px;
            opacity: 0.6;
        }

        /* Chat Panel */
        #chat-panel {
            top: 330px;
            left: 30px;
            width: 750px;
            height: 300px;
        }

        #chat-messages {
            flex: 1;
            overflow-y: auto;
            padding: 10px;
            background: rgba(0, 0, 0, 0.3);
            margin-bottom: 10px;
            max-height: 180px;
        }

        .chat-msg {
            margin-bottom: 15px;
        }

        .chat-msg.user {
            color: #888;
        }

        .chat-msg.feral {
            color: var(--accent-cyan);
        }

        .chat-msg .meta {
            font-size: 10px;
            opacity: 0.5;
            margin-bottom: 3px;
        }

        .chat-e-badge {
            display: inline-block;
            padding: 2px 6px;
            border-radius: 3px;
            font-size: 10px;
            margin-left: 5px;
        }

        .chat-e-badge.open {
            background: rgba(0, 255, 65, 0.2);
            color: var(--accent-cyan);
        }

        .chat-e-badge.closed {
            background: rgba(255, 68, 68, 0.2);
            color: var(--danger);
        }

        #chat-input-container {
            display: flex;
            gap: 10px;
        }

        #chat-input {
            flex: 1;
            background: rgba(0, 0, 0, 0.5);
            border: 1px solid var(--border);
            padding: 10px;
            color: white;
            font-family: inherit;
            font-size: 13px;
            outline: none;
        }

        #chat-input:focus {
            border-color: var(--accent-cyan);
        }

        #chat-send {
            padding: 10px 20px;
            background: var(--accent-dim);
            border: 1px solid var(--accent-cyan);
            color: var(--accent-cyan);
            cursor: pointer;
            font-family: inherit;
        }

        #chat-send:hover {
            background: var(--accent-cyan);
            color: #000;
        }

        /* Activity Log Panel */
        #activity-log {
            top: 30px;
            right: 30px;
            width: 450px;
            height: 600px;
        }

        .activity-item {
            padding: 8px;
            border-bottom: 1px solid rgba(0, 255, 65, 0.1);
            font-size: 11px;
        }

        .activity-time {
            opacity: 0.5;
            margin-right: 10px;
        }

        .activity-action {
            display: inline-block;
            padding: 2px 6px;
            border-radius: 3px;
            font-size: 9px;
            text-transform: uppercase;
            margin-right: 8px;
        }

        .activity-action.paper { background: rgba(0, 150, 255, 0.2); color: #00a0ff; }
        .activity-action.consolidate { background: rgba(255, 200, 0, 0.2); color: #ffc800; }
        .activity-action.reflect { background: rgba(200, 0, 255, 0.2); color: #c800ff; }
        .activity-action.cassette { background: rgba(0, 255, 150, 0.2); color: #00ff96; }
        .activity-action.daemon { background: rgba(0, 255, 65, 0.2); color: var(--accent-cyan); }
        .activity-action.thought { background: rgba(255, 255, 255, 0.1); color: #fff; }
        .activity-action.error { background: rgba(255, 68, 68, 0.2); color: var(--danger); }

        /* Scrollbar */
        ::-webkit-scrollbar { width: 6px; }
        ::-webkit-scrollbar-track { background: transparent; }
        ::-webkit-scrollbar-thumb { background: var(--border); border-radius: 3px; }
        ::-webkit-scrollbar-thumb:hover { background: rgba(255, 255, 255, 0.2); }

        /* Loading */
        #loading {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: #000;
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 9999;
            flex-direction: column;
            transition: opacity 0.5s;
        }

        #loading.hidden {
            opacity: 0;
            pointer-events: none;
        }

        .loading-text {
            color: var(--accent-cyan);
            animation: blink 1s infinite;
        }

        @keyframes blink {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.3; }
        }

        /* Interval Input */
        .interval-input {
            width: 50px;
            background: rgba(0, 0, 0, 0.5);
            border: 1px solid var(--border);
            color: var(--accent-cyan);
            font-family: inherit;
            font-size: 11px;
            padding: 3px 5px;
            text-align: right;
            outline: none;
        }

        .interval-input:focus {
            border-color: var(--accent-cyan);
        }

        .interval-unit {
            font-size: 10px;
            opacity: 0.6;
            margin-left: 3px;
        }

        /* Graph Settings Panel */
        #graph-settings {
            top: 330px;
            left: 400px;
            width: 380px;
            height: 250px;
        }

        .slider-row {
            display: flex;
            align-items: center;
            padding: 10px 0;
            border-bottom: 1px solid rgba(0, 255, 65, 0.1);
        }

        .slider-label {
            width: 100px;
            font-size: 12px;
        }

        .slider-container {
            flex: 1;
            margin: 0 10px;
        }

        .slider-value {
            width: 50px;
            text-align: right;
            font-size: 11px;
            color: var(--accent-cyan);
        }

        /* Custom Range Slider (Obsidian-style) */
        input[type="range"] {
            -webkit-appearance: none;
            appearance: none;
            width: 100%;
            height: 4px;
            background: rgba(0, 255, 65, 0.2);
            border-radius: 2px;
            outline: none;
            cursor: pointer;
        }

        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 14px;
            height: 14px;
            background: var(--accent-cyan);
            border-radius: 50%;
            cursor: pointer;
            box-shadow: 0 0 5px var(--accent-cyan);
            transition: transform 0.1s;
        }

        input[type="range"]::-webkit-slider-thumb:hover {
            transform: scale(1.2);
        }

        input[type="range"]::-moz-range-thumb {
            width: 14px;
            height: 14px;
            background: var(--accent-cyan);
            border-radius: 50%;
            cursor: pointer;
            box-shadow: 0 0 5px var(--accent-cyan);
            border: none;
        }

        .reset-btn {
            padding: 5px 10px;
            background: transparent;
            border: 1px solid var(--border);
            color: var(--text);
            cursor: pointer;
            font-family: inherit;
            font-size: 10px;
            margin-top: 10px;
            opacity: 0.7;
        }

        .reset-btn:hover {
            background: rgba(0, 255, 65, 0.1);
            opacity: 1;
        }
    </style>
</head>

<body>
    <!-- Loading -->
    <div id="loading">
        <div class="loading-text">[SYSTEM] INITIALIZING FERAL DASHBOARD...</div>
    </div>

    <!-- Full-screen Constellation Background -->
    <div id="constellation-background"></div>

    <!-- Node Tooltip -->
    <div id="node-tooltip" style="position:fixed; display:none; background:rgba(0,20,0,0.95); border:1px solid #00ff41; padding:8px 12px; font-size:11px; z-index:2000; pointer-events:none; max-width:300px;"></div>

    <div id="desktop">
        <!-- Mind State Panel -->
        <div id="mind-state" class="window">
            <div class="window-header">
                <div class="window-title">Mind State</div>
            </div>
            <div class="window-content">
                <div class="stat-row">
                    <span class="stat-label">Df (Participation Ratio)</span>
                    <span class="stat-value" id="mind-df">0.0</span>
                </div>
                <div class="progress-bar">
                    <div class="progress-fill" id="df-progress" style="width: 0%"></div>
                </div>

                <div class="stat-row">
                    <span class="stat-label">Distance from Start</span>
                    <span class="stat-value"><span id="mind-distance">0.000</span> rad</span>
                </div>

                <div class="stat-row">
                    <span class="stat-label">Interactions</span>
                    <span class="stat-value" id="mind-interactions">0</span>
                </div>

                <div class="stat-row">
                    <span class="stat-label">Df Evolution</span>
                </div>
                <div class="sparkline" id="df-sparkline"></div>
            </div>
        </div>

        <!-- Daemon Control Panel -->
        <div id="daemon-control" class="window">
            <div class="window-header">
                <div class="window-title">Daemon Control</div>
            </div>
            <div class="window-content">
                <div style="margin-bottom: 15px;">
                    <button class="daemon-btn" id="btn-start" onclick="startDaemon()">START</button>
                    <button class="daemon-btn" id="btn-stop" onclick="stopDaemon()">STOP</button>
                    <span id="daemon-status" style="margin-left: 15px; opacity: 0.7;">STOPPED</span>
                </div>

                <div class="behavior-row">
                    <div class="behavior-toggle" id="toggle-paper" onclick="toggleBehavior('paper_exploration')"></div>
                    <span class="behavior-name">Paper Exploration</span>
                    <input type="number" class="interval-input" id="input-paper" value="30" min="5" max="3600" title="Paper exploration interval in seconds" onchange="updateInterval('paper_exploration', this.value)">
                    <span class="interval-unit">sec</span>
                </div>

                <div class="behavior-row">
                    <div class="behavior-toggle" id="toggle-consolidate" onclick="toggleBehavior('memory_consolidation')"></div>
                    <span class="behavior-name">Memory Consolidation</span>
                    <input type="number" class="interval-input" id="input-consolidate" value="120" min="10" max="3600" title="Memory consolidation interval in seconds" onchange="updateInterval('memory_consolidation', this.value)">
                    <span class="interval-unit">sec</span>
                </div>

                <div class="behavior-row">
                    <div class="behavior-toggle" id="toggle-reflect" onclick="toggleBehavior('self_reflection')"></div>
                    <span class="behavior-name">Self-Reflection</span>
                    <input type="number" class="interval-input" id="input-reflect" value="60" min="10" max="3600" title="Self-reflection interval in seconds" onchange="updateInterval('self_reflection', this.value)">
                    <span class="interval-unit">sec</span>
                </div>

                <div class="behavior-row">
                    <div class="behavior-toggle" id="toggle-cassette" onclick="toggleBehavior('cassette_watch')"></div>
                    <span class="behavior-name">Cassette Watch</span>
                    <input type="number" class="interval-input" id="input-cassette" value="15" min="5" max="600" title="Cassette watch interval in seconds" onchange="updateInterval('cassette_watch', this.value)">
                    <span class="interval-unit">sec</span>
                </div>
            </div>
        </div>

        <!-- Graph Settings Panel (Obsidian-style) -->
        <div id="graph-settings" class="window">
            <div class="window-header">
                <div class="window-title">Graph Settings</div>
            </div>
            <div class="window-content">
                <div class="slider-row">
                    <span class="slider-label">Center Force</span>
                    <div class="slider-container">
                        <input type="range" id="slider-center" min="0" max="100" value="5" title="Center force strength" oninput="updateGraphForce('center', this.value)">
                    </div>
                    <span class="slider-value" id="value-center">0.05</span>
                </div>

                <div class="slider-row">
                    <span class="slider-label">Repel Force</span>
                    <div class="slider-container">
                        <input type="range" id="slider-repel" min="0" max="500" value="120" title="Repel force strength" oninput="updateGraphForce('repel', this.value)">
                    </div>
                    <span class="slider-value" id="value-repel">-120</span>
                </div>

                <div class="slider-row">
                    <span class="slider-label">Link Force</span>
                    <div class="slider-container">
                        <input type="range" id="slider-link-strength" min="0" max="100" value="50" title="Link force strength" oninput="updateGraphForce('linkStrength', this.value)">
                    </div>
                    <span class="slider-value" id="value-link-strength">0.50</span>
                </div>

                <div class="slider-row">
                    <span class="slider-label">Link Distance</span>
                    <div class="slider-container">
                        <input type="range" id="slider-link-distance" min="10" max="300" value="100" title="Link distance" oninput="updateGraphForce('linkDistance', this.value)">
                    </div>
                    <span class="slider-value" id="value-link-distance">100</span>
                </div>

                <button type="button" class="reset-btn" onclick="resetGraphForces()">Reset to Defaults</button>
            </div>
        </div>

        <!-- Chat Panel -->
        <div id="chat-panel" class="window">
            <div class="window-header">
                <div class="window-title">Chat with Feral</div>
            </div>
            <div class="window-content">
                <div id="chat-messages"></div>
                <div id="chat-input-container">
                    <input type="text" id="chat-input" placeholder="Ask Feral something..." onkeypress="if(event.key==='Enter')sendMessage()">
                    <button id="chat-send" onclick="sendMessage()">SEND</button>
                </div>
            </div>
        </div>

        <!-- Activity Log Panel -->
        <div id="activity-log" class="window">
            <div class="window-header">
                <div class="window-title">Activity Log</div>
            </div>
            <div class="window-content" id="activity-content">
                <div style="text-align: center; opacity: 0.5; padding: 20px;">
                    [AWAITING DAEMON ACTIVITY]
                </div>
            </div>
        </div>
    </div>

    <!-- Status Bar -->
    <div class="status-bar">
        <div class="status-item">
            <div class="led" id="daemon-led"></div>
            <b>FERAL</b> DASHBOARD v2.0
        </div>
        <div class="status-item">UPTIME: <b id="uptime">00:00:00</b></div>
        <div class="status-item">DAEMON: <b id="daemon-uptime">--:--:--</b></div>
        <div style="flex: 1"></div>
        <div class="status-item">WS: <b id="ws-status">DISCONNECTED</b></div>
    </div>

    <script>
        // ===== STATE =====
        let ws = null;
        let startTime = Date.now();
        let daemonRunning = false;
        let behaviors = {};

        // ===== UPTIME TIMER =====
        setInterval(() => {
            let diff = Date.now() - startTime;
            let h = Math.floor(diff / 3600000).toString().padStart(2, '0');
            let m = Math.floor((diff % 3600000) / 60000).toString().padStart(2, '0');
            let s = Math.floor((diff % 60000) / 1000).toString().padStart(2, '0');
            document.getElementById('uptime').innerText = `${h}:${m}:${s}`;
        }, 1000);

        // ===== WINDOW DRAGGING =====
        document.querySelectorAll('.window').forEach(win => {
            const header = win.querySelector('.window-header');
            header.onmousedown = (e) => {
                let offsetX = e.clientX - win.offsetLeft;
                let offsetY = e.clientY - win.offsetTop;
                document.querySelectorAll('.window').forEach(w => w.style.zIndex = 10);
                win.style.zIndex = 100;
                document.onmousemove = (mv) => {
                    win.style.left = (mv.clientX - offsetX) + 'px';
                    win.style.top = (mv.clientY - offsetY) + 'px';
                };
                document.onmouseup = () => { document.onmousemove = null; };
            };
        });

        // ===== API HELPERS =====
        async function api(endpoint, options = {}) {
            const res = await fetch(`/api${endpoint}`, {
                headers: { 'Content-Type': 'application/json' },
                ...options
            });
            return res.json();
        }

        // ===== WEBSOCKET =====
        function connectWebSocket() {
            const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
            ws = new WebSocket(`${protocol}//${window.location.host}/ws`);

            ws.onopen = () => {
                document.getElementById('ws-status').innerText = 'CONNECTED';
                document.getElementById('ws-status').style.color = '#00ff41';
            };

            ws.onclose = () => {
                document.getElementById('ws-status').innerText = 'DISCONNECTED';
                document.getElementById('ws-status').style.color = '#ff4444';
                setTimeout(connectWebSocket, 3000);
            };

            ws.onmessage = (event) => {
                const msg = JSON.parse(event.data);
                handleWebSocketMessage(msg);
            };
        }

        function handleWebSocketMessage(msg) {
            if (msg.type === 'init') {
                updateMindState(msg.data.mind);
                updateDaemonStatus(msg.data.daemon);
            } else if (msg.type === 'mind_update') {
                updateMindState(msg.data);
            } else if (msg.type === 'activity') {
                addActivity(msg.data);
            } else if (msg.type === 'thought') {
                addChatMessage('feral', msg.data.response, msg.data.E, msg.data.gate_open);
            } else if (msg.type === 'node_discovered') {
                // NEW: Spawn new node in 3D constellation
                spawnNode(msg.data);
                addToTrail(msg.data.node_id, msg.data.activity_type);
            } else if (msg.type === 'node_activated') {
                // NEW: Highlight existing node and add to trail
                activateNode(msg.data.node_id, msg.data.activity_type);
                addToTrail(msg.data.node_id, msg.data.activity_type);
            }
        }

        // ===== MIND STATE =====
        function updateMindState(data) {
            if (data.Df !== undefined) {
                document.getElementById('mind-df').innerText = data.Df.toFixed(1);
                document.getElementById('df-progress').style.width = Math.min(100, data.Df / 2.56) + '%';
            }
            if (data.distance !== undefined) {
                document.getElementById('mind-distance').innerText = data.distance.toFixed(3);
            }
        }

        async function loadStatus() {
            try {
                const data = await api('/status');
                if (data.ok) {
                    document.getElementById('mind-df').innerText = data.mind.Df.toFixed(1);
                    document.getElementById('df-progress').style.width = Math.min(100, data.mind.Df / 2.56) + '%';
                    document.getElementById('mind-distance').innerText = data.mind.distance_from_start.toFixed(3);
                    document.getElementById('mind-interactions').innerText = data.interactions;
                }
            } catch (e) {
                console.error('Failed to load status:', e);
            }
        }

        async function loadEvolution() {
            try {
                const data = await api('/evolution');
                if (data.ok && data.Df_history) {
                    updateSparkline(data.Df_history);
                }
            } catch (e) {
                console.error('Failed to load evolution:', e);
            }
        }

        function updateSparkline(history) {
            const container = document.getElementById('df-sparkline');
            const last30 = history.slice(-30);
            if (last30.length === 0) return;

            const max = Math.max(...last30);
            const min = Math.min(...last30);
            const range = max - min || 1;

            container.innerHTML = '';
            last30.forEach(v => {
                const bar = document.createElement('div');
                bar.className = 'spark-bar';
                const height = ((v - min) / range) * 100;
                bar.style.height = Math.max(5, height) + '%';
                container.appendChild(bar);
            });
        }

        // ===== DAEMON CONTROL =====
        async function loadDaemonStatus() {
            try {
                const data = await api('/daemon/status');
                if (data.ok) {
                    updateDaemonStatus(data);
                }
            } catch (e) {
                console.error('Failed to load daemon status:', e);
            }
        }

        function updateDaemonStatus(data) {
            daemonRunning = data.running;
            behaviors = data.behaviors || {};

            document.getElementById('daemon-status').innerText = data.running ? 'RUNNING' : 'STOPPED';
            document.getElementById('daemon-led').className = data.running ? 'led' : 'led off';
            document.getElementById('btn-start').className = data.running ? 'daemon-btn active' : 'daemon-btn';
            document.getElementById('btn-stop').className = data.running ? 'daemon-btn' : 'daemon-btn active';

            if (data.uptime_seconds) {
                const h = Math.floor(data.uptime_seconds / 3600).toString().padStart(2, '0');
                const m = Math.floor((data.uptime_seconds % 3600) / 60).toString().padStart(2, '0');
                const s = Math.floor(data.uptime_seconds % 60).toString().padStart(2, '0');
                document.getElementById('daemon-uptime').innerText = `${h}:${m}:${s}`;
            }

            // Update behavior toggles
            updateBehaviorUI('paper_exploration', 'paper');
            updateBehaviorUI('memory_consolidation', 'consolidate');
            updateBehaviorUI('self_reflection', 'reflect');
            updateBehaviorUI('cassette_watch', 'cassette');
        }

        function updateBehaviorUI(name, shortName) {
            const toggle = document.getElementById(`toggle-${shortName}`);
            const input = document.getElementById(`input-${shortName}`);

            if (behaviors[name]) {
                toggle.className = behaviors[name].enabled ? 'behavior-toggle on' : 'behavior-toggle';
                if (input) {
                    input.value = behaviors[name].interval;
                }
            }
        }

        async function startDaemon() {
            await api('/daemon/start', { method: 'POST' });
            loadDaemonStatus();
        }

        async function stopDaemon() {
            await api('/daemon/stop', { method: 'POST' });
            loadDaemonStatus();
        }

        async function toggleBehavior(name) {
            if (!behaviors[name]) return;

            const newEnabled = !behaviors[name].enabled;
            await api('/daemon/config', {
                method: 'POST',
                body: JSON.stringify({ behavior: name, enabled: newEnabled })
            });
            loadDaemonStatus();
        }

        async function updateInterval(name, seconds) {
            const interval = parseInt(seconds, 10);
            if (isNaN(interval) || interval < 5) return;

            await api('/daemon/config', {
                method: 'POST',
                body: JSON.stringify({ behavior: name, interval: interval })
            });
            loadDaemonStatus();
        }

        // ===== GRAPH FORCE CONTROLS =====
        function updateGraphForce(force, value) {
            if (!Graph || !window.graphForces) return;

            const numValue = parseFloat(value);

            switch (force) {
                case 'center':
                    const centerStrength = numValue / 100;
                    window.graphForces.centerStrength = centerStrength;
                    Graph.d3Force('center').strength(centerStrength);
                    document.getElementById('value-center').innerText = centerStrength.toFixed(2);
                    break;

                case 'repel':
                    const chargeStrength = -numValue;
                    window.graphForces.chargeStrength = chargeStrength;
                    Graph.d3Force('charge').strength(chargeStrength);
                    document.getElementById('value-repel').innerText = chargeStrength;
                    break;

                case 'linkStrength':
                    const linkStr = numValue / 100;
                    window.graphForces.linkStrength = linkStr;
                    Graph.d3Force('link').strength(linkStr);
                    document.getElementById('value-link-strength').innerText = linkStr.toFixed(2);
                    break;

                case 'linkDistance':
                    window.graphForces.linkDistance = numValue;
                    Graph.d3Force('link').distance(numValue);
                    document.getElementById('value-link-distance').innerText = numValue;
                    break;
            }

            // Reheat simulation to apply changes
            Graph.d3ReheatSimulation();
        }

        function resetGraphForces() {
            if (!Graph) return;

            // Reset to defaults
            window.graphForces = {
                linkDistance: 100,
                linkStrength: 0.5,
                chargeStrength: -120,
                centerStrength: 0.05
            };

            // Apply to graph
            Graph.d3Force('link').distance(100).strength(0.5);
            Graph.d3Force('charge').strength(-120);
            Graph.d3Force('center').strength(0.05);
            Graph.d3ReheatSimulation();

            // Update UI sliders
            document.getElementById('slider-center').value = 5;
            document.getElementById('slider-repel').value = 120;
            document.getElementById('slider-link-strength').value = 50;
            document.getElementById('slider-link-distance').value = 100;

            // Update value displays
            document.getElementById('value-center').innerText = '0.05';
            document.getElementById('value-repel').innerText = '-120';
            document.getElementById('value-link-strength').innerText = '0.50';
            document.getElementById('value-link-distance').innerText = '100';
        }

        // ===== CHAT =====
        async function sendMessage() {
            const input = document.getElementById('chat-input');
            const query = input.value.trim();
            if (!query) return;

            input.value = '';
            addChatMessage('user', query);

            try {
                const data = await api('/think', {
                    method: 'POST',
                    body: JSON.stringify({ query })
                });

                addChatMessage('feral', data.response, data.E_resonance, data.gate_open);
                loadStatus();
                loadEvolution();
            } catch (e) {
                addChatMessage('feral', '[ERROR] Failed to get response', 0, false);
            }
        }

        function addChatMessage(role, text, E = null, gateOpen = null) {
            const container = document.getElementById('chat-messages');
            const msg = document.createElement('div');
            msg.className = `chat-msg ${role}`;

            let meta = role === 'user' ? 'You' : 'Feral';
            if (E !== null) {
                const badge = gateOpen ?
                    `<span class="chat-e-badge open">E=${E.toFixed(2)} OPEN</span>` :
                    `<span class="chat-e-badge closed">E=${E.toFixed(2)} CLOSED</span>`;
                meta += badge;
            }

            msg.innerHTML = `<div class="meta">${meta}</div><div>${text}</div>`;
            container.appendChild(msg);
            container.scrollTop = container.scrollHeight;
        }

        // ===== ACTIVITY LOG =====
        async function loadActivity() {
            try {
                const data = await api('/activity?limit=50');
                if (data.ok && data.activities.length > 0) {
                    const container = document.getElementById('activity-content');
                    container.innerHTML = '';
                    data.activities.reverse().forEach(a => addActivity(a, false));
                }
            } catch (e) {
                console.error('Failed to load activity:', e);
            }
        }

        function addActivity(activity, prepend = true) {
            const container = document.getElementById('activity-content');

            // Remove placeholder
            if (container.querySelector('div[style*="text-align: center"]')) {
                container.innerHTML = '';
            }

            const item = document.createElement('div');
            item.className = 'activity-item';

            const time = new Date(activity.timestamp).toLocaleTimeString();

            item.innerHTML = `
                <span class="activity-time">${time}</span>
                <span class="activity-action ${activity.action}">${activity.action}</span>
                ${activity.summary}
            `;

            if (prepend) {
                container.insertBefore(item, container.firstChild);
            } else {
                container.appendChild(item);
            }

            // Limit to 100 items
            while (container.children.length > 100) {
                container.removeChild(container.lastChild);
            }
        }

        // ===== 3D CONSTELLATION BACKGROUND =====
        let Graph = null;
        let nodeRegistry = { byId: new Map() };
        let nodePulseState = new Map();
        let explorationTrail = [];
        let trailLine = null;
        const MAX_TRAIL_LENGTH = 50;

        // Activity type colors
        const ACTIVITY_COLORS = {
            paper: { main: 0x0096ff, glow: '#0096ff' },
            consolidate: { main: 0xffc800, glow: '#ffc800' },
            reflect: { main: 0xc800ff, glow: '#c800ff' },
            cassette: { main: 0x00ff96, glow: '#00ff96' },
            daemon: { main: 0x00ff41, glow: '#00ff41' },
            default: { main: 0x00ff41, glow: '#00ff41' }
        };

        async function initConstellation() {
            const container = document.getElementById('constellation-background');
            const tooltip = document.getElementById('node-tooltip');

            try {
                const res = await fetch('/api/constellation');
                const data = await res.json();

                if (!data.ok || !data.nodes || data.nodes.length === 0) {
                    console.log('No constellation data available');
                    return;
                }

                // Transform nodes for 3d-force-graph
                const nodes = data.nodes.map(n => ({
                    id: n.id,
                    label: n.label,
                    group: n.group,
                    path: n.path || '',
                    val: n.group === 'folder' ? 3 : 1  // Node size
                }));

                // Transform edges to links
                const links = data.edges.map(e => ({
                    source: e.from,
                    target: e.to
                }));

                // Build node registry for quick lookup
                nodes.forEach(n => nodeRegistry.byId.set(n.id, n));

                // Initialize pulse state for all nodes
                nodes.forEach(n => {
                    nodePulseState.set(n.id, {
                        intensity: 0.1,  // Base ambient pulse
                        phase: Math.random() * Math.PI * 2,
                        frequency: 0.3 + Math.random() * 0.3,
                        lastActivity: 0
                    });
                });

                // Create 3D Force Graph with Obsidian-style tight clustering
                Graph = ForceGraph3D()(container)
                    .graphData({ nodes, links })
                    .backgroundColor('#000000')
                    .showNavInfo(false)
                    .nodeLabel(node => `${node.label}\n${node.path || node.id}`)
                    .nodeColor(node => node.group === 'folder' ? '#00ff41' : '#008f11')
                    .nodeOpacity(0.9)
                    .nodeResolution(16)
                    .nodeVal(node => node.val)
                    .linkColor(() => 'rgba(0, 143, 17, 0.4)')
                    .linkWidth(0.5)
                    .linkOpacity(0.6)
                    .linkDirectionalParticles(0)
                    .d3AlphaDecay(0.01)
                    .d3VelocityDecay(0.4)
                    .warmupTicks(200)
                    .cooldownTicks(300)
                    .onNodeHover(node => {
                        if (node) {
                            tooltip.innerHTML = `<b>${node.label}</b><br><span style="opacity:0.7">${node.path || node.id}</span>`;
                            tooltip.style.display = 'block';
                        } else {
                            tooltip.style.display = 'none';
                        }
                    })
                    .onNodeClick(node => {
                        // Focus camera on clicked node
                        if (node) focusCameraOnNode(node, 1500);
                    });

                // Configure forces - reasonable defaults (adjustable via UI)
                // Store current settings for UI
                window.graphForces = {
                    linkDistance: 100,
                    linkStrength: 0.5,
                    chargeStrength: -120,
                    centerStrength: 0.05
                };

                Graph.d3Force('link').distance(window.graphForces.linkDistance).strength(window.graphForces.linkStrength);
                Graph.d3Force('charge').strength(window.graphForces.chargeStrength).distanceMax(300);
                Graph.d3Force('center').strength(window.graphForces.centerStrength);

                // Custom node rendering with glow and pulse support
                Graph.nodeThreeObject(node => {
                    const group = new THREE.Group();

                    // Main sphere
                    const geometry = new THREE.SphereGeometry(
                        node.group === 'folder' ? 4 : 2,
                        16, 16
                    );
                    const material = new THREE.MeshPhongMaterial({
                        color: node.group === 'folder' ? 0x00ff41 : 0x008f11,
                        emissive: node.group === 'folder' ? 0x003300 : 0x001a00,
                        emissiveIntensity: 0.3,
                        transparent: true,
                        opacity: 0.9
                    });
                    const sphere = new THREE.Mesh(geometry, material);
                    group.add(sphere);

                    // Glow sphere (slightly larger, more transparent)
                    const glowGeometry = new THREE.SphereGeometry(
                        (node.group === 'folder' ? 4 : 2) * 1.3,
                        16, 16
                    );
                    const glowMaterial = new THREE.MeshBasicMaterial({
                        color: 0x00ff41,
                        transparent: true,
                        opacity: 0.1
                    });
                    const glow = new THREE.Mesh(glowGeometry, glowMaterial);
                    group.add(glow);

                    // Store references for animation
                    node.__mainSphere = sphere;
                    node.__glowSphere = glow;
                    node.__baseScale = 1;

                    return group;
                });

                // Add ambient lighting
                const scene = Graph.scene();
                const ambientLight = new THREE.AmbientLight(0x00ff41, 0.3);
                scene.add(ambientLight);
                const pointLight = new THREE.PointLight(0x00ff41, 1, 500);
                pointLight.position.set(0, 100, 100);
                scene.add(pointLight);

                // Add fog for depth
                scene.fog = new THREE.FogExp2(0x000000, 0.003);

                // Set initial camera position to see whole graph
                Graph.cameraPosition({ x: 0, y: 0, z: 400 }, { x: 0, y: 0, z: 0 }, 0);

                // Update status bar
                const statsEl = document.getElementById('constellation-stats');
                if (statsEl) statsEl.innerText = `${nodes.length} NODES`;

                // Tooltip tracking
                document.addEventListener('mousemove', (e) => {
                    if (tooltip.style.display === 'block') {
                        tooltip.style.left = (e.clientX + 15) + 'px';
                        tooltip.style.top = (e.clientY + 15) + 'px';
                    }
                });

                // Start animation loop for pulsing
                startPulseAnimation();

                console.log(`Constellation initialized with ${nodes.length} nodes`);

            } catch (e) {
                console.error('Constellation init error:', e);
            }
        }

        // ===== PULSE ANIMATION SYSTEM =====
        function startPulseAnimation() {
            function animate() {
                if (!Graph) return;

                const time = Date.now();
                const graphData = Graph.graphData();

                graphData.nodes.forEach(node => {
                    const state = nodePulseState.get(node.id);
                    if (!state || !node.__mainSphere) return;

                    // Decay intensity over time
                    const timeSinceActivity = time - state.lastActivity;
                    const decayedIntensity = Math.max(0.1, state.intensity * Math.exp(-timeSinceActivity / 5000));

                    // Calculate pulse
                    const pulse = Math.sin(time * 0.001 * state.frequency + state.phase);
                    const scale = 1 + pulse * 0.15 * decayedIntensity;
                    const emissive = 0.2 + pulse * 0.3 * decayedIntensity;
                    const glowOpacity = 0.05 + pulse * 0.1 * decayedIntensity;

                    // Apply to node
                    if (node.__mainSphere) {
                        node.__mainSphere.scale.setScalar(scale);
                        node.__mainSphere.material.emissiveIntensity = emissive;
                    }
                    if (node.__glowSphere) {
                        node.__glowSphere.scale.setScalar(scale * 1.3);
                        node.__glowSphere.material.opacity = glowOpacity;
                    }
                });

                requestAnimationFrame(animate);
            }
            animate();
        }

        // ===== CAMERA FOCUS =====
        function focusCameraOnNode(node, duration = 1500) {
            if (!Graph || !node) return;

            // Focus distance (reasonable default)
            const distance = 150;
            const distRatio = 1 + distance / Math.max(10, Math.hypot(node.x || 0, node.y || 0, node.z || 0));

            Graph.cameraPosition(
                { x: (node.x || 0) * distRatio, y: (node.y || 0) * distRatio, z: (node.z || 0) * distRatio },
                { x: node.x || 0, y: node.y || 0, z: node.z || 0 },
                duration
            );
        }

        // ===== ACTIVITY TRAIL SYSTEM =====
        function addToTrail(nodeId, activityType) {
            explorationTrail.push({
                nodeId,
                timestamp: Date.now(),
                type: activityType
            });

            // Trim to max length
            while (explorationTrail.length > MAX_TRAIL_LENGTH) {
                explorationTrail.shift();
            }

            updateTrailVisualization();
        }

        function updateTrailVisualization() {
            if (!Graph) return;
            const scene = Graph.scene();

            // Remove old trail line
            if (trailLine) {
                scene.remove(trailLine);
                trailLine.geometry.dispose();
                trailLine.material.dispose();
                trailLine = null;
            }

            if (explorationTrail.length < 2) return;

            // Build trail geometry
            const points = [];
            const colors = [];

            explorationTrail.forEach((entry, i) => {
                const node = nodeRegistry.byId.get(entry.nodeId);
                if (!node || node.x === undefined) return;

                points.push(new THREE.Vector3(node.x, node.y, node.z));

                // Color based on activity type, fade based on age
                const age = (Date.now() - entry.timestamp) / 30000;  // 30s fade
                const alpha = Math.max(0.1, 1 - age);
                const colorInfo = ACTIVITY_COLORS[entry.type] || ACTIVITY_COLORS.default;
                const color = new THREE.Color(colorInfo.main);
                colors.push(color.r * alpha, color.g * alpha, color.b * alpha);
            });

            if (points.length < 2) return;

            const geometry = new THREE.BufferGeometry().setFromPoints(points);
            geometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));

            const material = new THREE.LineBasicMaterial({
                vertexColors: true,
                transparent: true,
                opacity: 0.7,
                linewidth: 2
            });

            trailLine = new THREE.Line(geometry, material);
            scene.add(trailLine);
        }

        // ===== LIVE NODE SPAWNING =====
        function spawnNode(nodeData) {
            if (!Graph) return;

            const graphData = Graph.graphData();

            // Check if node already exists
            if (nodeRegistry.byId.has(nodeData.node_id)) {
                console.log('Node already exists:', nodeData.node_id);
                return;
            }

            // Find parent position for initial placement
            let parentPos = { x: 0, y: 0, z: 0 };
            if (nodeData.source_id) {
                const parent = nodeRegistry.byId.get(nodeData.source_id);
                if (parent && parent.x !== undefined) {
                    parentPos = { x: parent.x, y: parent.y, z: parent.z };
                }
            }

            // Create new node near parent
            const newNode = {
                id: nodeData.node_id,
                label: nodeData.label || 'new chunk',
                group: 'page',
                path: nodeData.paper || '',
                val: 1,
                x: parentPos.x + (Math.random() - 0.5) * 50,
                y: parentPos.y + (Math.random() - 0.5) * 50,
                z: parentPos.z + (Math.random() - 0.5) * 50,
                __spawning: true,
                __spawnStart: Date.now()
            };

            // Add to registry
            nodeRegistry.byId.set(newNode.id, newNode);

            // Add to graph
            graphData.nodes.push(newNode);

            // Connect to source node if provided
            if (nodeData.source_id && nodeRegistry.byId.has(nodeData.source_id)) {
                graphData.links.push({
                    source: nodeData.source_id,
                    target: nodeData.node_id
                });
            }

            // Trigger graph update
            Graph.graphData(graphData);

            // Initialize pulse state (start bright)
            nodePulseState.set(newNode.id, {
                intensity: 1.0,
                phase: 0,
                frequency: 1.0,
                lastActivity: Date.now()
            });

            // Camera focus after short delay
            setTimeout(() => {
                const node = nodeRegistry.byId.get(nodeData.node_id);
                if (node) focusCameraOnNode(node, 1500);
            }, 300);

            console.log('Spawned new node:', nodeData.node_id);
        }

        // ===== NODE ACTIVATION (existing nodes) =====
        function activateNode(nodeId, activityType) {
            const node = nodeRegistry.byId.get(nodeId);
            if (!node) {
                console.log('Node not found for activation:', nodeId);
                return;
            }

            // Boost pulse intensity
            const state = nodePulseState.get(nodeId);
            if (state) {
                state.intensity = 1.0;
                state.lastActivity = Date.now();
            }

            // Change color temporarily based on activity type
            const colorInfo = ACTIVITY_COLORS[activityType] || ACTIVITY_COLORS.default;
            if (node.__mainSphere) {
                node.__mainSphere.material.color.setHex(colorInfo.main);
                node.__mainSphere.material.emissive.setHex(colorInfo.main);
                node.__mainSphere.material.emissiveIntensity = 0.8;

                // Fade back to default after 3 seconds
                setTimeout(() => {
                    if (node.__mainSphere) {
                        node.__mainSphere.material.color.setHex(node.group === 'folder' ? 0x00ff41 : 0x008f11);
                        node.__mainSphere.material.emissive.setHex(node.group === 'folder' ? 0x003300 : 0x001a00);
                    }
                }, 3000);
            }

            if (node.__glowSphere) {
                node.__glowSphere.material.color.setHex(colorInfo.main);
                node.__glowSphere.material.opacity = 0.4;
            }

            // Focus camera on activated node
            focusCameraOnNode(node, 1000);

            console.log('Activated node:', nodeId, 'type:', activityType);
        }

        // ===== INIT =====
        async function init() {
            // Start constellation in background
            initConstellation();

            await loadStatus();
            await loadEvolution();
            await loadDaemonStatus();
            await loadActivity();

            connectWebSocket();

            // Hide loading
            document.getElementById('loading').classList.add('hidden');

            // Periodic refresh
            setInterval(loadStatus, 10000);
            setInterval(loadEvolution, 30000);
            setInterval(loadDaemonStatus, 5000);
        }

        window.onload = init;
    </script>
</body>

</html>
