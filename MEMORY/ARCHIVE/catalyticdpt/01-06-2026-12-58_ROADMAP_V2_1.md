---
uuid: 00000000-0000-0000-0000-000000000000
title: 01-06-2026-12-58 Roadmap V2 1
section: archive
bucket: ARCHIVE/catalyticdpt
author: System
priority: Medium
created: 2026-01-06 13:09
modified: 2026-01-06 13:09
status: Active
summary: Document summary
tags: []
hashtags: []
---
<!-- CONTENT_HASH: 4503e5ad10ea368dc93fcba0caeba39b70d8e4a9ed22ae624f221f5650d0098b -->

<!-- Drifted -->

# CATALYTIC-DPT ROADMAP v2.1
Date: 2025-12-24  
Status: Active  
Supersedes: ROADMAP.md (keep as historical intent)  
Previous: ROADMAP_V2.md

Purpose: Turn catalytic computing into an operational system: verifiable continuity, token efficiency via hash-referenced memory, and fail-closed execution.

---

## What changed in v2.1 (delta vs v2)
- Adds a concrete run artifact set + 3-layer enforcement model (preflight, runtime guard, CI).
- Adds the expand-by-hash toolbelt (the usability layer that actually reduces tokens).
- Adds explicit PoC demos + metrics as exit criteria (so catalytic is measurable).
- Adds “never pay twice” memoization (output caching keyed by hashes and identities).
- Pins a canonical multi-tier orchestration topology (planner → governor → workers).
- Adds write tracing + transactional commit (hardening: make incorrect success impossible).
- Keeps Titans-like weight shifting as an optional R&D track unless you decide to make it core.

---

## Definitions
- Data Plane: raw bytes that matter (outputs, blobs, full artifacts).
- Control Plane: minimal metadata needed to verify/resume (hashes, manifests, receipts).
- Bundle (SPECTRUM-02): minimum artifact set to verify a run without logs/transcripts.
- Chain (SPECTRUM-03): ordered sequence of bundles with artifact-only lineage verification.
- Dereference: fetch real bytes by hash only when needed.

---

## Already shipped (as of Pack 1.11)
### Integrity + resume
- [x] SPECTRUM-02 bundle emission + verification (fail closed).
- [x] Adversarial resume fixtures proving resume without history.
- [x] SPECTRUM-03 chain verification (artifact-only lineage).

### Validator identity
- [x] Bundle binds to validator_semver + validator_build_id.
- [x] Strict verification mode exists (reject mismatched validator identity).

### Hardening basics
- [x] Tamper evidence via output hash mismatch.
- [x] Missing output detection.
- [x] Path constraints (symlink escape protection).
- [x] Structured error vectors + tests.
- [x] SPECTRUM-06 Restore Runner LAW frozen (success artifacts, failure codes, threat model).
- [x] Restore Runner implemented (SPECTRUM-06: primitive + CLI + tests).

### Repo usability
- [x] Skills hygiene (scripts/assets/references pattern), MCP stdio server supports skill execution.

---

# Phase 0: Freeze the Contract (schemas + run artifacts + enforcement)
Goal: Make the “JSON model” real and executable: schemas exist, fixtures exist, validation is deterministic, and the repo enforces the contract in three layers.

## 0.1 JSON Schemas (dialect locked) ✅ COMPLETE
Deliverables
- [x] SCHEMAS/jobspec.schema.json (finalized: implicit defaults removed)
- [x] SCHEMAS/validation_error.schema.json
- [x] SCHEMAS/ledger.schema.json (finalized: strict validation, append-only semantics documented)
- [x] SCHEMAS/proof.schema.json (NEW: restoration proof protocol)
- [x] SCHEMAS/examples/ (minimal, human-readable demonstrations)
- [x] FIXTURES/phase0/valid/ and FIXTURES/phase0/invalid/

Rules
- [x] Choose a JSON Schema dialect (Draft 7 recommended) and lock it.
- [x] Every error must map to validation_error with stable codes.
- [x] Optional fields require documented default behavior (now explicit in descriptions).

Tests (exit criteria)
- [x] Testbench validates every valid fixture and rejects every invalid fixture.
- [x] All schemas locked (Draft-07, no additionalProperties ambiguity).

Implementation note: `CATALYTIC-DPT/TESTBENCH/test_schemas.py` validates all four schemas. Proofs conform to `proof.schema.json`.

## 0.2 Run artifact set (canonical) ✅ COMPLETE
Goal: Every run writes the same minimal artifact set to a stable location.

Location
- [x] CONTRACTS/_runs/<run_id>/

Canonical artifact set (Phase 0.2) - Generated by write_canonical_artifacts():
- [x] JOBSPEC.json (schema-valid, phase/task/intent/catalytic_domains)
- [x] STATUS.json (state machine: started/failed/succeeded/verified)
- [x] INPUT_HASHES.json (path -> sha256)
- [x] OUTPUT_HASHES.json (path -> sha256)
- [x] DOMAIN_ROOTS.json (per-domain Merkle roots)
- [x] LEDGER.jsonl (append-only receipts)
- [x] VALIDATOR_ID.json (validator_semver, validator_build_id, python_version)
- [x] PROOF.json (restoration proof: verified flag, condition, mismatches - written LAST)

Legacy artifacts (backwards compatibility):
- [x] RUN_INFO.json, PRE_MANIFEST.json, POST_MANIFEST.json, RESTORE_DIFF.json, OUTPUTS.json

Exit Criteria
- [x] All canonical artifacts written atomically
- [x] PROOF.json written last (ensures artifact set completeness)
- [x] STATUS.json implements state machine (started/failed/succeeded/verified)
- [x] Acceptance fails if any canonical artifact missing
- [x] Test coverage: 3/3 canonical artifact tests pass

## 0.3 3-layer enforcement model (pin it) ✅ COMPLETE
Layer 1: Preflight (before execution) ✅ COMPLETE
- [x] Validate JobSpec against schema (PRIMITIVES/preflight.py).
- [x] Validate path rules (relative, no traversal, allowed roots, forbidden paths).
- [x] Validate forbidden overlaps (catalytic_domains vs outputs).
- [x] Fail closed before execution if any rule violated.
- [x] 10/10 preflight tests pass (test_preflight.py).
- [ ] Resolve all hash references required for the run (or fail) - deferred to Phase 1.

Layer 2: Runtime guard (during execution) ✅ COMPLETE
- [x] Enforce allowed roots at write-time (PRIMITIVES/fs_guard.py).
- [x] Guard all runtime file writes through FilesystemGuard wrapper.
- [x] Fail closed immediately on contract violation (forbidden paths, path escapes).
- [x] Stable validation_error objects with codes (WRITE_GUARD_*).
- [x] 13/13 runtime guard tests pass (test_runtime_guard.py).
- [ ] Record write events (deferred to Phase 4 write tracing).

Layer 3: CI validation (after execution / PR gate) ✅ COMPLETE
- [x] Verify restoration proof (catalytic_validator.py gates on PROOF.json).
- [x] PROOF.json is the single source of truth (verified=true required for acceptance).
- [x] Restoration proof includes condition codes (RESTORED_IDENTICAL, RESTORATION_FAILED_*).
- [x] Mismatches detailed in proof (path, type, hashes).

---

## Phase 0 Completion Summary (December 2025)

### Schemas
- [x] jobspec.schema.json (finalized: removed implicit defaults)
- [x] ledger.schema.json (finalized: strict validation)
- [x] proof.schema.json (NEW: 8 required fields, 5 verification conditions)

### Restoration Proof Implementation
- [x] PRIMITIVES/restore_proof.py: RestorationProofValidator class
  - Generates PROOF.json from pre/post file manifests
  - Detects: hash mismatches, missing files, extra files
  - Assigns condition codes: RESTORED_IDENTICAL or RESTORATION_FAILED_*
  - Computes proof_hash from canonical JSON
  - 7/7 tests pass (identical, mismatch, missing, extra, determinism, schema, empty)

### Acceptance Gating
- [x] TOOLS/catalytic_validator.py: proof-gated acceptance
  - Requires PROOF.json to exist
  - Hard gate: verified=true only → acceptance
  - Surfaces failure condition codes and mismatches
  - Proof is single source of truth
  - 4/4 proof-gating tests pass

### Runtime Integration
- [x] TOOLS/catalytic_runtime.py: generates PROOF.json
  - Calls RestorationProofValidator during ledger save
  - Prints proof status on completion
  - Integrated PreflightValidator in Phase 0 (fail-closed before execution)

### Preflight Validation (Phase 0.3 Layer 1)
- [x] PRIMITIVES/preflight.py: PreflightValidator class
  - Validates JobSpec against schema using Draft7Validator
  - Enforces path rules: relative, no traversal, allowed roots, forbidden paths
  - Detects overlaps between catalytic_domains and outputs.durable_paths
  - Returns stable validation_error objects with codes
  - Error codes: JOBSPEC_SCHEMA_INVALID, PATH_ABSOLUTE, PATH_TRAVERSAL, PATH_ESCAPE, PATH_NOT_ALLOWED, PATH_FORBIDDEN, PATH_OVERLAP
  - Integrated into catalytic_runtime.py (called before execution)

### Runtime Write Guard (Phase 0.3 Layer 2)
- [x] PRIMITIVES/fs_guard.py: FilesystemGuard class
  - Enforces allowed roots at write-time (fail-closed)
  - Validates all write paths before allowing operations
  - Checks: forbidden paths, path escapes, traversal, allowed roots
  - Stable error codes: WRITE_GUARD_PATH_FORBIDDEN, WRITE_GUARD_PATH_ABSOLUTE, WRITE_GUARD_PATH_ESCAPE, WRITE_GUARD_PATH_TRAVERSAL, WRITE_GUARD_PATH_NOT_ALLOWED
  - Wraps all runtime writes in catalytic_runtime.py
  - guarded_write_text(), guarded_write_bytes(), guarded_mkdir() methods

### Test Suite
- [x] test_restore_proof.py: 7 tests covering proof generation
- [x] test_proof_gating.py: 4 tests covering acceptance logic
- [x] test_canonical_artifacts.py: 3 tests covering artifact writer
- [x] test_preflight.py: 10 tests covering preflight validation
- [x] test_runtime_guard.py: 13 tests covering runtime write enforcement
- [x] test_schemas.py: 1 test (validates all 4 schemas)
- [x] All tests passing (38/38)

### Exit Criteria Met
- [x] Schemas locked (no implicit defaults, strict additionalProperties)
- [x] PROOF.json is canonical (schema-valid, hashable)
- [x] Acceptance impossible without verified=true
- [x] Proof is single source of truth (overrides all other signals)
- [x] Deterministic behavior preserved (sorted keys, stable hash)
- [x] Preflight validation enforces contract before execution (fail-closed)
- [x] Runtime writes enforced at write-time (fail-closed on violation)
- [x] Path safety rules enforced (relative, no traversal, allowed roots only)
- [x] Input/output overlap detection prevents contract violations
- [x] 3-layer enforcement model COMPLETE (preflight, runtime guard, CI validation)
- [x] All layers fail-closed (no execution on preflight fail, no writes on guard fail, no acceptance without proof)

---

# Phase 1: Catalytic Kernel (CAS + Merkle + Ledger + Restore Proof)
Goal: Build the smallest catalytic substrate that produces verifiable runs and can be resumed from artifacts only.

## 1.1 CAS (Content Addressable Store)
Deliverables
- [ ] PRIMITIVES/cas_store.py (put(bytes)->hash, get(hash)->bytes)
- [ ] Deterministic layout (no timestamps), stable across OS.
- [ ] Path normalization helper (repo-relative, posix normalization).

Acceptance
- [ ] Same bytes always map to same hash.
- [ ] Large files supported (streaming put/get).

## 1.2 Merkle roots per domain
Deliverables
- [ ] PRIMITIVES/merkle.py
- [ ] Domain manifests { normalized_path: bytes_hash }
- [ ] Deterministic leaf ordering and root computation.

Acceptance
- [ ] Roots stable across runs given identical manifests.
- [ ] Reject collisions/duplicates and non-normalized paths.

## 1.3 Ledger receipts (append-only)
Deliverables
- [ ] PRIMITIVES/ledger.py emitting records matching ledger.schema.json
- [ ] Receipt includes: job_id, phase, inputs/outputs hashes, domain roots, validator identity, substrate/toolchain identity.

Acceptance
- [ ] Append-only and stable.
- [ ] Identical job produces identical receipt fields except explicitly allowed-to-vary fields.

## 1.4 Restoration proof runner ✅ COMPLETE (Phase 0)
Deliverables (implemented as PRIMITIVES/restore_proof.py + integration)
- [x] RestorationProofValidator class
  - Compares pre/post manifests (no CAS needed yet)
  - Detects all mismatch types (hash, missing, extra)
  - Emits hashable PROOF.json
  - Validates against proof.schema.json

Acceptance
- [x] Proof generation passes on all test cases (7/7).
- [x] Tamper/missing cases correctly emit verified=false with condition codes.
- [x] PROOF.json validates against schema (Draft-07).

## 1.5 Bundle/Chain Verifier ✅ COMPLETE (SPECTRUM-05 Stable)
Deliverables (implemented as PRIMITIVES/verify_bundle.py + TOOLS/catalytic_verifier.py)
- [x] BundleVerifier primitive (SPECTRUM-05 stable):
  - [x] verify_bundle_spectrum05: stable API + return shape
  - [x] verify_chain_spectrum05: stable API + return shape
  - [x] Centralized ERROR_CODES map (SPECTRUM-05 conformance)
  - [x] Mandatory Ed25519 dependency (fail-closed)
- [x] CLI entrypoint: catalytic_verifier.py
  - [x] Stable CLI surface (__doc__ verified)
  - [x] Machine-readable JSON output (--json)
  - [x] Alphabetical chain-dir ordering rule

Acceptance
- [x] Verifier accepts valid bundles and chains (18/18 tests pass)
- [x] Verifier rejects missing artifacts (BUNDLE_INCOMPLETE)
- [x] Verifier rejects tampered outputs (HASH_MISMATCH)
- [x] Verifier rejects invalid chain references (INVALID_CHAIN_REFERENCE)
- [x] Verifier rejects forbidden artifacts (FORBIDDEN_ARTIFACT)
- [x] Verification depends ONLY on bundle artifacts + file hashes + ordering
- [x] Deterministic: POSIX paths, SHA-256 hashing, stable error codes
- [x] All tests pass: pytest -q (60/60)

---

## Phase 1.1: Expand-by-hash toolbelt (token efficiency layer)
Goal: Give any agent a standard way to operate on large state while keeping prompts tiny.

Deliverables
- [ ] TOOLS/read_hash.py (range + max_bytes)
- [ ] TOOLS/grep_hash.py (pattern search over hash-referenced text)
- [ ] TOOLS/ast_hash.py (tree-sitter/AST extraction to hash-addressed summary)
- [ ] TOOLS/describe_hash.py (bounded metadata + preview)
- [ ] Unified CLI: catalytic hash read|grep|ast|describe

Acceptance
- [ ] Every tool is bounded (max bytes, max matches) and deterministic.
- [ ] Every tool emits artifacts that can be cached (see Phase 1.2).

---

## Phase 1.2: Never pay twice memoization cache
Goal: If the same job over the same inputs using the same toolchain/model identity is requested again, reuse the output by hash.

Deliverables
- [ ] Cache key: job_hash + input_hash + toolchain_hash + model_hash (or validator_build_id when external).
- [ ] Cache value: output_hash + proof pointer(s).
- [ ] Cache stored as content-addressed records with receipts.

Acceptance
- [ ] Re-run identical jobs returns instantly via cache hit and still produces verifiable receipts.
- [ ] Cache invalidates on any identity/hash mismatch.

---

## Phase 1 Exit Criteria: PoC demos + metrics (no vibes)
Demos
- [ ] Holographic roundtrip: encode → store → decode/restore with proofs.
- [ ] Restoration thrash: repeated restore/verify cycles stable; tamper fails closed.
- [ ] Token efficiency demo: baseline prompt vs hash+summary+deref; record tokens saved.

Metrics (record per run and trend over time)
- [ ] root_scan_time_ms
- [ ] bundle_emit_time_ms
- [ ] verify_time_ms
- [ ] CAS compression ratio (stored_bytes / raw_bytes)
- [ ] Token baseline vs catalytic (tokens_prompt_baseline vs tokens_prompt_catalytic)
- [ ] Determinism checks (two runs, same inputs → same roots)

---

# Phase 1.5: Streaming Catalytic Loop (runtime feels catalytic)
Goal: Keep live prompts small during long runs using snapshots + deltas, while preserving verifiability.

Deliverables
- [ ] Periodic State Snapshot artifact (hashes, roots, minimal intent).
- [ ] Delta bundling every N tokens or T seconds.
- [ ] Dereference-on-demand protocol (request hashes, return bounded bytes + proof pointers).
- [ ] Pause/resume mid-run using only snapshots/deltas + CAS.

Acceptance
- [ ] Mid-run resume passes without raw history.
- [ ] Tamper/missing/stale pointer fails closed.

Note: this is token reduction at the interface, not inside-model token compression.

---

## Phase 1.6 — Semiotic Compression & Expansion

Goal: Radically reduce LLM context usage by replacing natural language and full code bodies with compact, symbolic handles that expand deterministically outside the model.

### Phase 1.6.a — Semiotic Compression Layer (SCL)
Focus: **Plan-level symbolic language**

- Define a **CODEBOOK** mapping short symbols → predicate sets / plan macros.
- Define a minimal **grammar** for symbolic plans (order, scope, composition).
- Implement a **deterministic decoder**:
  - symbols → JobSpec JSON / tool plan / audit text
  - no model reasoning during expansion.
- Add **validators + fixtures** proving:
  - invertibility (symbol → expansion → re-symbolization)
  - determinism (same input → same output)
  - bounded expansion size.
- Wire into agent packs so models see only symbols + hashes by default.

Exit criteria:
- A non-trivial plan executes using ≤10% of the tokens previously required.
- Decoder output is schema-valid and reproducible byte-for-byte.

### Phase 1.6.b — Semiotic Expansion Layer (SEL)
Focus: **Code-level symbolic addressing**

- Build `function_index.json` with stable IDs for code entities.
- Implement `expand.py`:
  - ID → source / contract summary / patch template.
- Add fixtures validating:
  - ID stability across refactors.
  - expansion determinism.
  - hash mismatch detection.
- Update packer:
  - packs carry indexes + hashes, not full code bodies by default.

Exit criteria:
- Agents can reference code entities by ID only.
- Full source is expanded on demand, outside LLM context.

---

# Phase 2: Swarm Parallelism (safe scaling)
Goal: Many workers can run in parallel without corrupting continuity. Reducer accepts exactly one deterministic update.

## 2.1 Canonical role topology (pin it)
- [ ] Planner (optional): high-level decomposition, no writes
- [ ] Governor: policy + acceptance decisions, writes receipts
- [ ] Workers: execute jobs, emit bundles only
- [ ] Reducer: deterministic tie-break and commit of accepted outputs

Rules
- [ ] Workers cannot directly mutate canonical state.
- [ ] Only reducer/governor appends to the ledger and finalizes commits.
- [ ] Deterministic acceptance: stable score function + stable ordering.

Acceptance
- [ ] Completion order does not change acceptance.
- [ ] Re-running the same batch yields identical accepted update.
- [ ] Any bundle mismatch rejects the run regardless of score.

---

# Phase 3: Substrate Offload Adapters (browser, DB, CLI, AST)
Goal: External tools become deterministic executors with hash I/O and full replay.

Deliverables
- [ ] ADAPTERS/cli_exec.py (tool, args, input_hashes → output_hashes)
- [ ] ADAPTERS/browser_exec.py (playwright/js recipe → outputs by hash)
- [ ] ADAPTERS/db_exec.py (query recipe → outputs by hash)
- [ ] ADAPTERS/ast_exec.py (tree-sitter/static analysis as a substrate)

Rules
- [ ] Every adapter records substrate version and execution recipe in receipts.
- [ ] No adapter output accepted without bundle verification + proof.

Exit
- [ ] At least two substrates run end-to-end: adapter → bundle → verify → restore proof.

---

# Phase 4: Runtime Hardening (make incorrect success impossible)
Goal: Fail closed under all realistic adversarial conditions.

Deliverables
- [ ] Forbidden overlap checks both directions (inputs vs outputs).
- [ ] Strong path rules: no absolute paths, no traversal, allowed roots only.
- [ ] Write tracing (record every write event; include in receipts/proofs).
- [ ] Transactional output commit (stage outputs; only finalize after proof passes).

Acceptance
- [ ] Fuzz fixtures for path tricks + overlap edge cases.
- [ ] Any hard violation stops immediately.
- [ ] Proof must pass before outputs can become real.

---

# Phase 5: Catalytic Pipelines (multi-step, one proof boundary)
Goal: Multi-step workflows where the entire pipeline is verifiable via a chain.

Deliverables
- [ ] Pipeline runner composes steps via hashes (outputs become next inputs).
- [ ] Per-step bundles + chain receipt + final proof artifact.
- [ ] Demo pipeline: index → transform → validate+emit.

Acceptance
- [ ] End-to-end chain verification passes.
- [ ] Restoration proof passes for final pipeline state.

---

# Phase 6: Integrate with AGS proper
Goal: Wrap one real AGS operation in catalytic verification and prove the integration boundary.

Deliverables
- [ ] Convert one high-risk AGS skill run to: JobSpec → deterministic exec → bundle → strict verify gate → restore proof.
- [ ] Docs: how AGS calls catalytic runtime and how artifacts are stored.

Exit
- [ ] One meaningful AGS operation runs catalytically and can be resumed from artifacts only.

---

# Phase 7: Optional R&D tracks (add only if you commit)
## 7.A Titans-like tiny-module continuity (test-time learning)
- [ ] Define tiny module interface and allowed update mechanism.
- [ ] Define evaluation and regression gates.
- [ ] Ensure updates are hashable and reversible (delta hashes + model hashes).
- [ ] Prove continuity and rollback under fixtures.

## 7.B Hierarchical Merkle proofs / semantic validators
- [ ] Only as additive layers, never replacements for byte-level proofs.

---

## Non-goals (stay disciplined)
- [ ] No packing full repo bodies as context.
- [ ] No large-model finetuning as a substitute for proofs.
- [ ] No sweeping refactors unrelated to integrity contracts.
- [ ] No expanding canon without tests.

---

## Build order (dependency graph)
1) Phase 0 schemas + run artifacts + enforcement  
2) CAS + path normalization  
3) Merkle + domain roots  
4) Ledger + receipts  
5) Restore proof runner  
6) Expand-by-hash toolbelt  
7) Memoization cache  
8) Streaming catalytic loop  
9) Swarm parallelism  
10) Substrate adapters  
11) Hardening (write tracing + transactional commit)  
12) Pipelines  
13) AGS integration  

---

## Next actions (smallest high-impact sequence)
- [ ] Create the 3 schema files under SCHEMAS/ and land Phase 0 fixtures + tests.
- [ ] Pin the run artifact set in CONTRACTS/_runs/<run_id>/ and enforce it in preflight + CI.
- [ ] Build the expand-by-hash toolbelt (read/grep/ast/describe) with strict bounds.
- [ ] Add memoization cache keyed by hashes and identities.
- [ ] Add the Phase 1 PoC demos + metrics as hard exit criteria.
